{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to TableVault","text":"<p>TableVault is a tool to manage data artifacts in complex and dynamic data workflows. It enables the reusability of data by ensuring that the complete context of data transformations is captured, and that data states are atomic and transactional (transformations clearly succeed or fail). Its designed to work well with various Python data science libraries and tools (Jupyter notebooks, Colab, Pandas, Numpy, transformers, and etc).</p> <p>TableVault is particularly suited to deal with workflows that deal with multiple dataframes, external artifacts (images, videos, documents, and etc), and large language model executions. Check out the Examples section for more detailed applications.</p> <p>You can install the tool with:</p> <pre><code>!pip install \"git+https://github.com/j2zhao/tablevault.git\"\n</code></pre> <p>This library has been tested for <code>Python&gt;=3.11</code>.</p> <p>Note: Will be uploaded to the Python Package Index officially in July 2025.</p>"},{"location":"advanced/metadata/","title":"Metadata Documentation","text":"<p>This document describes the various files that a TableVault repository generates to track table metadata. While users should never modify these files, they offer valuable insight into the repository's underlying state. This page details each file type and its contents.</p>"},{"location":"advanced/metadata/#general-metadata","title":"General Metadata","text":""},{"location":"advanced/metadata/#metadatalogstxt-and-metadatalog_idstxt","title":"<code>metadata/logs.txt</code> and <code>metadata/log_ids.txt</code>","text":"<p>These files contain information about completed logs. <code>logs.txt</code> provides the full details, while <code>log_ids.txt</code> only contains the <code>process_id</code>.</p>"},{"location":"advanced/metadata/#metadataactive_logsjson","title":"<code>metadata/active_logs.json</code>","text":"<p>This file contains information about all currently active processes. This data can be directly queried using the TableVault API.</p>"},{"location":"advanced/metadata/#metadatatables_historyjson-metadatacolumns_historyjson-and-metadatatables_tempjson","title":"<code>metadata/tables_history.json</code>, <code>metadata/columns_history.json</code> and <code>metadata/tables_temp.json</code>","text":"<p>These files contain a record of all fully stored instances. For each instance, <code>tables_history.json</code> records:</p> <ul> <li>When the dataframe was first materialized (which may have been copied from a previous dataframe).</li> <li>When the instance was first materialized.</li> <li>When the instance ceased to be active.</li> </ul> <p><code>columns_history.json</code> records materializeation at a per-column level. <code>tables_temp.json</code> records all temporary table instances.</p> <p>All files are used internally for various functionalities and optimizations.</p>"},{"location":"advanced/metadata/#locks","title":"<code>locks/*</code>","text":"<p>TableVault uses file-based, custom read-write locks to enable multi-processing.</p>"},{"location":"advanced/metadata/#_temp","title":"<code>_temp/*</code>","text":"<p>During active operations, the previous state of files that could be overwritten is saved here. If an operation fails, this allows the repository's state to be safely restored.</p>"},{"location":"advanced/metadata/#metadataarchived_trash","title":"<code>metadata/ARCHIVED_TRASH/*</code>","text":"<p>When tables and instances are deleted, only their dataframes and artifacts are removed. All associated metadata is moved to this folder, allowing for future reference to the history of how tables were constructed.</p> <p>Note</p> <p>If storage space is critical, the files in this folder can be safely deleted. However, it is unlikely that these files will consume a significant amount of space.</p>"},{"location":"advanced/metadata/#locklock-file","title":"<code>lock.LOCK</code> file","text":"<p>This locking file ensures that only one process can write to the metadata at a time.</p>"},{"location":"advanced/metadata/#tablevault-file","title":"<code>.tablevault</code> file","text":"<p>This informs us that we are dealing with a TableVault repository.</p>"},{"location":"advanced/metadata/#table-and-instance-metadata","title":"Table and Instance Metadata","text":""},{"location":"advanced/metadata/#descriptionsyaml","title":"<code>descriptions.yaml</code>","text":"<p>Each TableVault repository, table and instance has a corresponding YAML description file for its specific metadata. While some metadata is autogenerated, users can also add optional information when creating these objects. This feature is intended to provide any useful, missing context.</p>"},{"location":"advanced/metadata/#dtypesjson","title":"<code>dtypes.json</code>","text":"<p>Each materialized instance dataframe includes a <code>dtypes.json</code> file that specifies the data type of each column. This file is useful for handling custom data types and for keeping track of <code>artifact_string</code> columns.</p>"},{"location":"advanced/metadata/#execution_archive-folder","title":"<code>EXECUTION_ARCHIVE/*</code> folder","text":"<p>Each executed instance has an <code>EXECUTION_ARCHIVE</code> folder that explicitly records the Python functions that were executed. This folder, along with the builders files, helps provide context for each folder.</p>"},{"location":"advanced/os/","title":"Operating System Differences","text":"<p>Due to underlying file system differences, TableVault's behavior on Windows/external drives differs in the following three ways:</p> <ul> <li> <p>The <code>metadata/lock.LOCK</code> file does not persist on Windows. This is a result of the underlying <code>filelock</code> library's implementation.</p> </li> <li> <p>Files are never marked as read-only on Windows/external drives (e.g. mounted Google Drive on Colab). Therefore, greater care must be taken to prevent accidental overwrites.</p> </li> <li> <p>Temporary files are copied rather than hardlinked for external drives. This can cause some slowdown in these systems.</p> </li> </ul>"},{"location":"api/builders/","title":"Builders and Custom Python Functions","text":""},{"location":"api/builders/#builder-file-configuration","title":"Builder File Configuration","text":"<p>Builders inform TableVault how to build a DataFrame upon instance execution. Builder files are YAML specifications that define how a table instance is constructed or modified.</p> <p>TableVault supports two built-in builder types:</p> <ol> <li><code>IndexBuilder</code>: Produces a new DataFrame, often by defining its primary key and core rows.</li> <li><code>ColumnBuilder</code>: Generates or mutates individual columns within the DataFrame established by the <code>IndexBuilder</code>.</li> </ol> <p>Each table instance that is executed must contain exactly one <code>IndexBuilder</code>. Additional <code>ColumnBuilder</code> files can be included to perform subsequent modifications.</p>"},{"location":"api/builders/#indexbuilder","title":"IndexBuilder","text":"<p>An <code>IndexBuilder</code> is used to produce the initial DataFrame for a table instance. It typically defines the primary structure, index, and the total set of rows, often involving operations like joins or initial data loading.</p> <p>Important: Each executed table instance must include exactly one <code>IndexBuilder</code> file, and this file must be named according to the pattern: <code>{table_name}_index.yaml</code>.</p> <pre><code>builder_type: IndexBuilder\n\nchanged_columns: ['COLUMN_NAMES']        # Output columns\npython_function: FUNCTION_NAME           # Function to execute\ncode_module: MODULE_NAME                 # Module containing the function\n\narguments:                               # Arguments passed to the function\n    ARGUMENT_NAME_1: ARG_VALUE\n    ARGUMENT_NAME_2: &lt;&lt;TABLE.COLUMN&gt;&gt;    # Reference to another table's column\n    ARGUMENT_NAME_3: ~ARTIFACT_FOLDER~   # Special keyword for artifact folder path\nn_threads: 1                             # Number of parallel workers (default 1)\n\n# Optional flags\nis_custom: false                         # True if using a user-supplied function in code_module\nreturn_type: dataframe                   # return type as one of [row-wise, dataframe, generator]\nprimary_key: ['COLUMN_NAMES']            # DataFrame primary key\nkeep_old: false                          # Keep original rows\n\n# Optional column dtypes\ndtypes:\n    COLUMN_NAME_1: Int64\n    COLUMN_NAME_2: Float64\n    COLUMN_NAME_3: artifact_string     # Special type for artifact paths\n\n# Optional explicit table dependencies\ndependencies: ['TABLE_NAME.COLUMNS']     # e.g., ['Orders.customer_id']\n</code></pre>"},{"location":"api/builders/#columnbuilder","title":"ColumnBuilder","text":"<p>A <code>ColumnBuilder</code> is used to add new columns or modify existing ones based on calculations or transformations. It operates on the DataFrame produced by the <code>IndexBuilder</code> (or a preceding <code>ColumnBuilder</code>).</p> <p>Important: Every <code>ColumnBuilder</code> must output a DataFrame that has the exact same number of rows as the DataFrame generated by the <code>IndexBuilder</code>. The columns it creates or overwrites must correspond to those listed in its <code>changed_columns</code> field.</p> <pre><code>builder_type: ColumnBuilder\n\nchanged_columns: ['COLUMN_NAMES']        # Output columns created / overwritten\n\npython_function: FUNCTION_NAME         # e.g., build_features\ncode_module: MODULE_NAME               # e.g., my_feature_lib\n\narguments:\n    ARGUMENT_NAME_1: ARG_VALUE           # Scalars, lists, environment variables, etc.\n    ARGUMENT_NAME_2: &lt;&lt;TABLE.COLUMN&gt;&gt;    # Table reference syntax\n    ARGUMENT_NAME_3: ~ARTIFACT_FOLDER~   # Special keyword for artifact folder path\nn_threads: 1                           # Parallel workers (default 1)\n\n# Optional flags\nis_custom: false                       # Mark as user-supplied (searches in code_functions)\nreturn_type: dataframe                 # return type as one of [row-wise, dataframe, generator]\n\n# Optional column dtypes\ndtypes:\n    COLUMN_NAME_1: Int64\n    COLUMN_NAME_2: Float64\n    COLUMN_NAME_3: artifact_string     # Special type for artifact paths\n\n# Optional explicit table dependencies\ndependencies: ['TABLE_NAME.COLUMNS']     # e.g., ['Products.price']\n</code></pre>"},{"location":"api/builders/#field-reference","title":"Field Reference","text":"Field Type Applicability Description <code>builder_type</code> <code>string</code> All Specifies the type of builder. Must be exactly <code>\"IndexBuilder\"</code> or <code>\"ColumnBuilder\"</code>. <code>changed_columns</code> <code>list[string]</code> All A list of column names that are introduced or modified by this builder. <code>python_function</code> <code>string</code> All The fully qualified name of the Python function to execute (e.g., <code>my_module.my_function</code>). The function must be able to accept the declared <code>arguments</code>. <code>code_module</code> <code>string</code> All The name of the Python module file (e.g., <code>my_processing_lib.py</code>) containing the function. Must have been added to the TableVault via the API. <code>arguments</code> <code>dict</code> All A key-value mapping passed to the <code>python_function</code>. Values can be scalars, lists, table references (<code>&lt;&lt;TABLE.COLUMN&gt;&gt;</code>), or the special keyword <code>~ARTIFACT_FOLDER~</code>. <code>n_threads</code> <code>int</code> All The number of parallel worker threads to use for processing. Default: <code>1</code>. <code>is_custom</code> <code>bool</code> All Indicates the function's source. If <code>true</code>, the function is loaded from a user-supplied <code>code_module</code>. If <code>false</code>, it's loaded from TableVault\u2019s built-in functions. Default: <code>false</code>. <code>return_type</code> <code>string</code> All Expected return format from <code>python_function</code>. Must be one of <code>row-wise</code>, <code>dataframe</code>, or <code>generator</code>. Default: <code>dataframe</code>. <code>keep_old</code> <code>bool</code> <code>IndexBuilder</code> only Determines how rows from a previous instance are handled. If <code>true</code>, existing rows not generated by the current run are kept. Default: <code>false</code>. <code>primary_key</code> <code>list[string]</code> <code>IndexBuilder</code> only (Optional) A list of column names that form a unique row identifier. If omitted, the row position is used. <code>dtypes</code> <code>dict</code> All (Optional) A mapping from column names to pandas data types (e.g., <code>{\"col1\": \"Int64\"}</code>). Used for type coercion and for declaring <code>artifact_string</code> columns. <code>dependencies</code> <code>list[string]</code> All (Optional) Overrides automatic dependency detection. A list of explicit table dependencies (e.g., <code>['Orders.*']</code>). Required if dependencies are not clear from <code>arguments</code>."},{"location":"api/builders/#special-keywords","title":"Special Keywords","text":"<p>TableVault builders support special keywords that are dynamically replaced with context-aware values at runtime. These keywords enable access to file paths and data from other tables, making configurations more powerful and flexible.</p> Keyword Syntax Scope Description Artifact Folder <code>~ARTIFACT_FOLDER~</code> <code>arguments</code> A placeholder that resolves to the absolute path of the artifact folder for the current instance run. It is essential for any function that needs to save or load artifact files. Table Reference <code>&lt;&lt;...&gt;&gt;</code> Most string fields A dynamic reference used to fetch data from other tables or the current table instance (<code>self</code>). The expression within the <code>&lt;&lt;...&gt;&gt;</code> is resolved and its value is substituted into the field. <p>Example Usage in <code>arguments</code>:</p> <pre><code>arguments:\n  # The ~ARTIFACT_FOLDER~ keyword provides the path for saving a generated file\n  artifact_output_path: ~ARTIFACT_FOLDER~\n\n  # The &lt;&lt;...&gt;&gt; syntax fetches a specific configuration value from another table\n  source_data_id: \"&lt;&lt;config_table.source_id[region::'US']&gt;&gt;\"\n</code></pre>"},{"location":"api/builders/#creating-new-tablevault-builder-function","title":"Creating New TableVault\u00a0Builder Function","text":"<p>Every builder YAML tells TableVault how to construct or modify the instance DataFrame.\u202f The <code>return_type</code> field aligns your Python function\u2019s output with the framework\u2019s expectations:</p> <code>return_type</code> Type Use Pattern Expected Return Output What TableVault does <code>dataframe</code> (default) Create whole table in one function Function returns one <code>pd.DataFrame</code> that already includes every column in <code>changed_columns</code>. Accepts the DataFrame as\u2011is and moves on. <code>row\u2011wise</code> Compute each row independently.\u201d Function is called once per input row and returns a scalar\u00a0or tuple representing that row\u2019s new values. Writes each returned row immediately; can run with multiple threads <code>generator</code> Generate rows incrementally in one function Function yields <code>(row_idx, row_tuple)</code> pairs in any row order. Writes each yielded row immediately; skipped indices remain untouched. <p>Important Notes</p> <ol> <li>Column order &amp; count\u00a0must match <code>changed_columns</code>. One column \u2192 you may return/yield a scalar.</li> <li>All values must coerce cleanly to the dtypes you declare (e.g. <code>artifact_string</code>).</li> <li>If you write artefact files, return relative paths (<code>my_plot.png</code>), not absolute ones.</li> <li>For resuming interrupted runs, rely on the previously saved-instance (you can access it by assigning <code>&lt;&lt;self&gt;&gt;</code> as an argument). Do not look at artifact files, since they might not be saved to your dataframe.</li> <li>For <code>row-wise</code> functions that correspond to an IndexBuilder, the function is called for each row in the original copied table.</li> <li>Arguments to <code>row-wise</code> will automatically resolve the <code>index</code> key-word as the current row's index.</li> </ol>"},{"location":"api/builders/#resumesafe-generator-template","title":"Resume\u2011Safe Generator Template","text":"<pre><code>from typing import Iterator, Any, Tuple\nimport pandas as pd\n\ndef process_rows_generator(\n    input_df: pd.DataFrame,           # rows still to process\n    self_df: pd.DataFrame,            # &lt;&lt;self&gt;&gt; \u2013 current materialised table\n    batch_size: int = 512,\n    *args, **kwargs\n) -&gt; Iterator[Tuple[int, Tuple[Any, ...]]]:\n    \"\"\"Yield `(row_idx, row_tuple)` while skipping already\u2011done rows.\"\"\"\n\n    processed = set(self_df.index)\n\n    for start in range(0, len(input_df), batch_size):\n        if start in processed:\n            continue  # resume logic\n        end = min(start + batch_size, len(input_df))\n\n        # \u2500\u2500\u2500 your expensive work here \u2500\u2500\u2500\n        batch   = input_df.iloc[start:end]\n        results = some_heavy_op(batch, *args, **kwargs)\n        row_val = tuple(results)       # aligns with `changed_columns`\n        # \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n        yield start, row_val\n</code></pre> <p>Why this pattern matters</p> <ul> <li>Atomic progress: Each yielded row is immediately committed. If your job dies, rerunning the builder simply skips what\u2019s already in <code>self_df</code>.</li> <li>Parallel\u2011friendly: TableVault can run other builders while yours is streaming.</li> </ul>"},{"location":"api/builders/#examples","title":"Examples","text":""},{"location":"api/builders/#example-1","title":"Example 1","text":"<p>An <code>IndexBuilder</code> that converts a <code>list</code> to a <code>DataFrame</code></p> Python CodeExample YAML Builder <pre><code>create_data_table_from_list(vals: list) -&gt; pandas.DataFrame:\n    return pd.DataFrame({\"row_index\": vals})\n</code></pre> <pre><code>builder_type: IndexBuilder\nchanged_columns: [row_index] # only single column\nprimary_key: [row_index]\npython_function: create_data_table_from_list\ncode_module: table_generation\narguments:    \n    vals: [2, 4, 6, 8]\nis_custom: false\n</code></pre>"},{"location":"api/builders/#example-2","title":"Example 2","text":"<p>A <code>ColumnBuilder</code> that saves an <code>fruit_image</code> file for each <code>fruit</code> key</p> Python CodeExample YAML Builder <pre><code>import shutil\n\ndef fetch_image_from_string(fruit: str, artifact_dir:str ):\n\n    file_path = f'./all_images/{fruit}.png' # pre-existing file\n    new_file_path = f'{artifact_dir}/{fruit}.png'\n\n    shutil.copy(file_path, new_file_path)\n\n    return f'{fruit}.png' # return relative path\n</code></pre> <pre><code>builder_type: ColumnBuilder\n\nchanged_columns: ['fruit_image']                        # Output columns\n\npython_function: create_data_table_from_table           # Function to execute\ncode_module: table_generation                           # Module containing the function\n\nis_custom: true                                         # Mark as user-supplied (searches in code_functions)\nreturn_type: row-wise                                       # Specifies if the function processes row by row\n\narguments:                                              # Arguments passed to the function\n    fruit: &lt;&lt;self.fruits[index]&gt;&gt; \n    artifact_dir: ~ARTIFACT_FOLDER~ \n\ndtypes:                                                 # Column Data Types \n    fruit_image: artifact_string            \n</code></pre>"},{"location":"api/builders/#example-3","title":"Example 3","text":"<p>An <code>IndexBuilder</code> that yields a batch of <code>GritLM</code> embedding to a new row</p> Python CodeExample YAML Builder <pre><code>from typing import Iterator\n    from tqdm import tqdm\n    from gritlm import GritLM\n    import pandas as pd\n    import numpy as np\n    import time\n    import os\n    import torch\n    import gc\n\n    def get_batch_embeddings(df:pd.DataFrame,\n                            self_df:pd.DataFrame,\n                            artifact_column: str,\n                            raw_instruction:str,\n                            batch_size:int,\n                            artifact_name:str,\n                            artifact_folder:str)-&gt; Iterator[tuple[int, tuple[int, str, float]]]:\n        gc.collect()\n        torch.cuda.empty_cache()\n        model = GritLM(\"GritLM/GritLM-7B\", torch_dtype=\"auto\", device_map=\"auto\", mode=\"embedding\")\n\n        for index, start_index in enumerate(tqdm(range(0, len(df), batch_size), desc=\"Batches\")):\n        start_time = time.time()\n        end_index = start_index + batch_size\n        artifact_name_ = artifact_name + f\"_{start_index}_{end_index}.npy\"\n        artifact_dir = os.path.join(artifact_folder, artifact_name_)\n        if start_index in self_df['start_index']:\n            continue\n        batch_df = df.iloc[start_index:end_index][artifact_column]\n        batch_texts = []\n        for file_path in batch_df:\n            with open(file_path, 'r') as f:\n                batch_texts.append(f.read())\n        ndarr = model.encode(batch_texts, batch_size=batch_size,\n                                instruction=raw_instruction).astype(np.float16)\n        end_time = time.time()\n        np.save(artifact_dir, ndarr)\n        yield (index, (start_index, artifact_name_, end_time - start_time))\n</code></pre> <pre><code>builder_type: IndexBuilder\n\nchanged_columns: ['start_index', 'artifact_name', 'elapsed_time']        # Output columns created / overwritten\nprimary_key: ['start_index'] \npython_function: get_batch_embeddings         # e.g., build_features\ncode_module: batch_embedding                  # e.g., my_feature_lib\n\narguments:\n    df: &lt;&lt;paper_abstract_store.artifact_name&gt;&gt;\n    self_df: &lt;&lt;self&gt;&gt;\n    artifact_column: artifact_name\n    raw_instruction: \"&lt;|embed|&gt;\\n\"\n    batch_size: 4\n    artifact_name: embeddings\n    artifact_folder: ~ARTIFACT_FOLDER~\n\nis_custom: true\nreturn_type: generator\n\ndtypes:\n    artifact_name: artifact_string\n    elapsed_time: float\n</code></pre>"},{"location":"api/code_functions/","title":"Default Code Functions","text":"<p>There are several simple code functions included with the <code>tablevault</code> library. You can execute them by specifying the right parameters in a YAML <code>Builder</code> file.</p>"},{"location":"api/code_functions/#dataframe-creation","title":"Dataframe Creation","text":"<p>These functions are loaded with <code>module_name: table_generation</code> and <code>is_custom: false</code>. They are meant to be used with an <code>IndexBuilder</code> YAML file.</p> <p>The YAML Builder tab has the specified arguments of the builder file for the specific functions. You may have to fill out additional arguments not shown.</p>"},{"location":"api/code_functions/#create_paper_table_from_folder","title":"<code>create_paper_table_from_folder</code>","text":"Python CodeYAML Builder <pre><code>create_paper_table_from_folder(\n    folder_dir: str,\n    copies: int,\n    artifact_folder: str,\n    extension: str ='.pdf'\n) -&gt; pandas.DataFrame\n</code></pre> <pre><code>builder_type: IndexBuilder\nchanged_columns: ['file_name', 'artifact_name', 'original_path']\nprimary_key: ['file_name']\npython_function: create_paper_table_from_folder\ncode_module: table_generation\narguments:\n    folder_dir: str\n    copies: int\n    artifact_folder: ~ARTIFACT_FOLDER~\n    extension: str\nis_custom: false\n\ndtypes:\n    artifact_name: artifact_string\n</code></pre> <p>Scan a directory for <code>extension</code> files, copy each into an artifact directory, and return a table describing every copy.</p> Parameter Type Description <code>folder_dir</code> <code>str</code> Folder containing the source PDFs <code>copies</code> <code>int</code> How many copies per file (\u22651) <code>artifact_folder</code> <code>str</code> Destination directory for the copies <code>extension</code> <code>str</code> File extension to be filtered <p>The resulting <code>DataFrame</code> has three columns:</p> <ol> <li><code>file_name</code> \u2013 base filename (without extension)</li> <li><code>artifact_name</code> \u2013 copied file\u2019s name (includes suffixes when <code>copies &gt; 1</code>)</li> <li><code>original_path</code> \u2013 path to the original PDF</li> </ol>"},{"location":"api/code_functions/#create_data_table_from_table","title":"<code>create_data_table_from_table</code>","text":"Python CodeYAML Builder <pre><code>create_data_table_from_table(\n    df: pandas.DataFrame,\n    nrows: int | None = None,\n    random_sample: bool = False\n) -&gt; pandas.DataFrame\n</code></pre> <pre><code>builder_type: IndexBuilder\nchanged_columns: list\npython_function: create_data_table_from_table\ncode_module: table_generation\narguments:\n    df: pandas.DataFrame\n    nrows: int # Optional\n    random_sample: bool # Optional (need nrows)\nis_custom: false\n</code></pre> <p>Return a copy of <code>df</code>, with optional truncation or random sampling.</p> Parameter Type Default Description <code>df</code> <code>pandas.DataFrame</code> Source data <code>nrows</code> <code>int</code> <code>None</code> Row limit (leave <code>None</code> for all rows) <code>random_sample</code> <code>bool</code> <code>False</code> If <code>True</code>, randomly sample <code>nrows</code> from <code>df</code>"},{"location":"api/code_functions/#create_data_table_from_csv","title":"<code>create_data_table_from_csv</code>","text":"Python CodeYAML Builder <pre><code>create_data_table_from_csv(csv_file_path: str) -&gt; pandas.DataFrame\n</code></pre> <pre><code>builder_type: IndexBuilder\nchanged_columns: list\npython_function: create_data_table_from_csv\ncode_module: table_generation\narguments:    \n    csv_file_path: str\nis_custom: false\n</code></pre> <p>Load a CSV file into a new <code>DataFrame</code> and return a copy.</p> Parameter Type Description <code>csv_file_path</code> <code>str</code> Path to the CSV on disk"},{"location":"api/code_functions/#create_data_table_from_list","title":"<code>create_data_table_from_list</code>","text":"Python CodeYAML Builder <pre><code>create_data_table_from_list(vals: list) -&gt; pandas.DataFrame\n</code></pre> <pre><code>builder_type: IndexBuilder\nchanged_columns: [str] # only single column\nprimary_key: [str]\npython_function: create_data_table_from_list\ncode_module: table_generation\narguments:    \n    vals: list\nis_custom: false\n</code></pre> <p>Turn an in-memory Python list into a single-column table.</p> Parameter Type Description <code>vals</code> <code>list</code> Values to place in the column"},{"location":"api/code_functions/#random-string-module","title":"Random String Module","text":""},{"location":"api/code_functions/#random_row_string","title":"<code>random_row_string</code>","text":"Python CodeYAML Builder <pre><code>random_row_string(column_names: list[str], **kwargs) -&gt; tuple[str, ...] | str\n</code></pre> <pre><code>builder_type: ColumnBuilder\nchanged_columns: [str]\npython_function: random_row_string\ncode_module: random_string\narguments:    \n    column_names: list[str] # same length as changed_columns\nis_custom: false\nreturn_type: row-wise\n</code></pre> <p>Produce a single tuple of random strings\u2014one per name in <code>column_names</code>.</p> Parameter Type Description <code>column_names</code> <code>list[str]</code> Column labels that determine tuple length <code>**kwargs</code> unused Reserved for future options <p>Returns: a length-<code>len(column_names)</code> tuple of 20-character strings or a singular string (if only one column).</p>"},{"location":"api/core_api/","title":"TableVault Python Interface","text":""},{"location":"api/core_api/#class-tablevault","title":"Class <code>TableVault</code>","text":"<pre><code>class TableVault()\n</code></pre> <p>Interface with a TableVault repository. Initialisation can create a new vault repository and optionally restart any active processes. Subsequent methods allow interaction with tables instances, code modules, and builder files within that vault.</p> Parameter Type Description Default <code>db_dir</code> <code>str</code> Directory path where the TableVault is stored (or should be created). \u2013 <code>author</code> <code>str</code> Name or identifier of the user/system performing the operations. \u2013 <code>description</code> <code>str</code> Description for the vault creation (used only when create is True). <code>\"\"</code> <code>create</code> <code>bool</code> If True, initialise a new vault at db_dir. <code>False</code> <code>restart</code> <code>bool</code> If True, restart any processes previously active in this vault. <code>False</code> <code>verbose</code> <code>bool</code> If True, prints detailed logs of every operation. <code>True</code>"},{"location":"api/core_api/#tablevault-data-creation-methods","title":"<code>TableVault</code> Data Creation Methods","text":""},{"location":"api/core_api/#create_table","title":"<code>create_table()</code>","text":"<pre><code>def create_table(\n    self,\n    table_name: str,\n    allow_multiple_artifacts: bool = False,\n    has_side_effects: bool = False,\n    process_id: str = \"\",\n    description: str = \"\",\n) -&gt; str:\n</code></pre> Parameter Type Description Default <code>table_name</code> <code>str</code> Name of the new table. \u2013 <code>allow_multiple_artifacts</code> <code>bool</code> True \u21d2 instance has own artifact folder; False \u21d2 one folder, one active. <code>False</code> <code>has_side_effects</code> <code>bool</code> True \u21d2 builders have side effects (e.g. API calls). <code>False</code> <code>process_id</code> <code>str</code> Calling process identifier. <code>\"\"</code> <code>description</code> <code>str</code> Description for the table. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#create_instance","title":"<code>create_instance()</code>","text":"<pre><code>def create_instance(\n    self,\n    table_name: str,\n    version: str = \"\",\n    origin_id: str = \"\",\n    origin_table: str = \"\",\n    external_edit: bool = False,\n    copy: bool = False,\n    builders: Optional[dict[str, str] | list[str]] = None,\n    process_id: str = \"\",\n    description: str = \"\",\n) -&gt; str:\n</code></pre> Parameter Type Description Default <code>table_name</code> <code>str</code> Name of the table. \u2013 <code>version</code> <code>str</code> Version of the table; empty \u21d2 <code>BASE_TABLE_VERSION</code>. <code>\"\"</code> <code>origin_id</code> <code>str</code> If supplied, copy state from this existing instance ID. <code>\"\"</code> <code>origin_table</code> <code>str</code> Table for <code>origin_id</code>; empty \u21d2 <code>table_name</code>. <code>\"\"</code> <code>external_edit</code> <code>bool</code> True \u21d2 instance edited externally, no builders constructed. <code>False</code> <code>copy</code> <code>bool</code> False (no <code>origin_id</code>) \u21d2 use latest materialised instance as origin if it exists. <code>True</code> <code>builders</code> <code>Optional[dict[str, str] \\| list[str]]</code> List of new builder names to generate. <code>None</code> <code>process_id</code> <code>str</code> Calling process identifier. <code>\"\"</code> <code>description</code> <code>str</code> Description for this instance. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#create_code_module","title":"<code>create_code_module()</code>","text":"<pre><code>def create_code_module(\n    self,\n    module_name: str = \"\",\n    copy_dir: str = \"\",\n    process_id: str = \"\"\n) -&gt; str:\n</code></pre> Parameter Type Description Default <code>module_name</code> <code>str</code> Name for the new module. <code>\"\"</code> <code>copy_dir</code> <code>str</code> Directory or Python file to copy. <code>\"\"</code> <code>process_id</code> <code>str</code> Calling process identifier. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#create_builder_file","title":"<code>create_builder_file()</code>","text":"<pre><code>def create_builder_file(\n    self,\n    table_name: str,\n    builder_name: str = \"\",\n    version: str = constants.BASE_TABLE_VERSION,\n    copy_dir: str = \"\",\n    process_id: str = \"\",\n) -&gt; str:\n</code></pre> Parameter Type Description Default <code>table_name</code> <code>str</code> Name of the table. \u2013 <code>builder_name</code> <code>str</code> Builder file name; empty \u21d2 inferred. <code>{table_name}_index</code> <code>version</code> <code>str</code> Version of the table. <code>constants.BASE_TABLE_VERSION</code> <code>copy_dir</code> <code>str</code> Directory containing builder file(s). <code>\"\"</code> <code>process_id</code> <code>str</code> Calling process identifier. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#tablevault-instance-materialization-methods","title":"<code>TableVault</code> Instance Materialization Methods","text":""},{"location":"api/core_api/#write_instance","title":"<code>write_instance()</code>","text":"<pre><code>def write_instance(\n    self,\n    table_df: pd.DataFrame,\n    table_name: str,\n    version: str = constants.BASE_TABLE_VERSION,\n    dependencies: Optional[list[tuple[str, str]]] = None,\n    dtypes: Optional[dict[str, str]] = None,\n    process_id: str = \"\",\n) -&gt; str:\n</code></pre> Parameter Type Description Default <code>table_df</code> <code>pd.DataFrame</code> Data to write. \u2013 <code>table_name</code> <code>str</code> Target table. \u2013 <code>version</code> <code>str</code> Target version. <code>constants.BASE_TABLE_VERSION</code> <code>dependencies</code> <code>Optional[list[tuple[str, str]]]</code> List of <code>(table_name, instance_id)</code> dependencies. None for no deps. <code>None</code> <code>dtypes</code> <code>Optional[dict[str, str]]</code> <code>{column: pandas-dtype}</code>. None for nullable defaults. <code>None</code> <code>process_id</code> <code>str</code> Calling process identifier. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 The process ID of the executed write operation.</p>"},{"location":"api/core_api/#execute_instance","title":"<code>execute_instance()</code>","text":"<pre><code>def execute_instance(\n    self,\n    table_name: str,\n    version: str = constants.BASE_TABLE_VERSION,\n    force_execute: bool = False,\n    process_id: str = \"\",\n    background: bool = False,\n) -&gt; str:\n</code></pre> Parameter Type Description Default <code>table_name</code> <code>str</code> Name of the table to materialise. \u2013 <code>version</code> <code>str</code> Version of the table. <code>constants.BASE_TABLE_VERSION</code> <code>force_execute</code> <code>bool</code> True \u21d2 force full rebuild; False \u21d2 reuse origin if possible. <code>False</code> <code>process_id</code> <code>str</code> Calling process identifier. <code>\"\"</code> <code>background</code> <code>bool</code> True \u21d2 run materialisation in background. <code>False</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#tablevault-data-deletionmodification-methods","title":"<code>TableVault</code> Data Deletion/Modification Methods","text":""},{"location":"api/core_api/#rename_table","title":"<code>rename_table()</code>","text":"<pre><code>def rename_table(\n    self, new_table_name: str, table_name: str, process_id: str = \"\"\n) -&gt; str:\n</code></pre> Parameter Type Description Default <code>new_table_name</code> <code>str</code> New table name. \u2013 <code>table_name</code> <code>str</code> Current table name. \u2013 <code>process_id</code> <code>str</code> Calling process identifier. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#delete_table","title":"<code>delete_table()</code>","text":"<pre><code>def delete_table(self, table_name: str, process_id: str = \"\") -&gt; str:\n</code></pre> Parameter Type Description Default <code>table_name</code> <code>str</code> Name of the table to delete. \u2013 <code>process_id</code> <code>str</code> Calling process identifier. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#delete_instance","title":"<code>delete_instance()</code>","text":"<pre><code>def delete_instance(\n    self, instance_id: str, table_name: str, process_id: str = \"\"\n) -&gt; str:\n</code></pre> Parameter Type Description Default <code>instance_id</code> <code>str</code> ID of the instance to delete. \u2013 <code>table_name</code> <code>str</code> Name of the table owns instance. \u2013 <code>process_id</code> <code>str</code> Calling process identifier. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#delete_code_module","title":"<code>delete_code_module()</code>","text":"<pre><code>def delete_code_module(self, module_name: str, process_id: str = \"\") -&gt; str:\n</code></pre> Parameter Type Description Default <code>module_name</code> <code>str</code> Name of the module to delete. \u2013 <code>process_id</code> <code>str</code> Calling process identifier. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#delete_builder_file","title":"<code>delete_builder_file()</code>","text":"<pre><code>def delete_builder_file(\n    self,\n    builder_name: str,\n    table_name: str,\n    version: str = constants.BASE_TABLE_VERSION,\n    process_id: str = \"\",\n) -&gt; str:\n</code></pre> Parameter Type Description Default <code>builder_name</code> <code>str</code> Name of the builder file to delete. \u2013 <code>table_name</code> <code>str</code> Owning table name. \u2013 <code>version</code> <code>str</code> Version of the table. <code>constants.BASE_TABLE_VERSION</code> <code>process_id</code> <code>str</code> Calling process identifier. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#tablevault-process-methods","title":"<code>TableVault</code> Process Methods","text":""},{"location":"api/core_api/#generate_process_id","title":"<code>generate_process_id()</code>","text":"<pre><code>def generate_process_id(self) -&gt; str:\n</code></pre> <p>Returns \u2192 <code>str</code> \u2013 A new, unique process identifier.</p>"},{"location":"api/core_api/#stop_process","title":"<code>stop_process()</code>","text":"<pre><code>def stop_process(\n    self,\n    to_stop_process_id: str,\n    force: bool = False,\n    materialize: bool = False,\n    process_id: str = \"\",\n) -&gt; str:\n</code></pre> <p>Stop an active process and optionally terminate it forcefully.</p> Parameter Type Description Default <code>to_stop_process_id</code> <code>str</code> ID of the process to stop. \u2013 <code>force</code> <code>bool</code> True \u21d2 forcibly stop; False \u21d2 raise if still running. <code>False</code> <code>materialize</code> <code>bool</code> True \u21d2 materialise partial instances if relevant. <code>False</code> <code>process_id</code> <code>str</code> ID of the calling process (audit). <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this stop_process call.</p>"},{"location":"api/core_api/#tablevault-data-fetching-methods","title":"<code>TableVault</code> Data Fetching Methods","text":""},{"location":"api/core_api/#get_dataframe","title":"<code>get_dataframe()</code>","text":"<pre><code>def get_dataframe(\n    self,\n    table_name: str,\n    instance_id: str = \"\",\n    version: str = constants.BASE_TABLE_VERSION,\n    active_only: bool = True,\n    successful_only: bool = False,\n    rows: Optional[int] = None,\n    full_artifact_path: bool = True,\n) -&gt; tuple[pd.DataFrame, str]:\n</code></pre> Parameter Type Description Default <code>table_name</code> <code>str</code> Name of the table. \u2013 <code>instance_id</code> <code>str</code> Specific instance ID; empty \u21d2 latest of version. <code>\"\"</code> <code>version</code> <code>str</code> Version when instance_id omitted. <code>constants.BASE_TABLE_VERSION</code> <code>active_only</code> <code>bool</code> True \u21d2 consider only active instances. <code>True</code> <code>successful_only</code> <code>bool</code> True \u21d2 consider only successful runs. <code>False</code> <code>rows</code> <code>Optional[int]</code> Row limit (<code>None</code> = no limit). <code>None</code> <code>full_artifact_path</code> <code>bool</code> True \u21d2 prefix <code>\"artifact_string\"</code> columns with the repository path <code>True</code> <p>Returns \u2192 <code>tuple[pd.DataFrame, str]</code> \u2013 (dataframe, resolved_instance_id).</p>"},{"location":"api/core_api/#get_file_tree","title":"<code>get_file_tree()</code>","text":"<pre><code>def get_file_tree(\n    self,\n    instance_id: str = \"\",\n    table_name: str = \"\",\n    code_files: bool = True,\n    builder_files: bool = True,\n    metadata_files: bool = False,\n    artifact_files: bool = False,\n) -&gt; rich.tree.Tree:\n</code></pre> <p>Return a RichTree object of files contained in the target.</p> Parameter Type Description Default <code>instance_id</code> <code>str</code> Resolve a specific instance (else latest). <code>\"\"</code> <code>table_name</code> <code>str</code> Limit to a table (optional). <code>\"\"</code> <code>code_files</code> <code>bool</code> Include stored code modules. <code>True</code> <code>builder_files</code> <code>bool</code> Include builder scripts. <code>True</code> <code>metadata_files</code> <code>bool</code> Include JSON/YAML metadata. <code>False</code> <code>artifact_files</code> <code>bool</code> Include artifact directory contents. <code>False</code> <p>Returns \u2192 <code>rich.tree.Tree</code> \u2013 printable file-tree representation.</p>"},{"location":"api/core_api/#get_instances","title":"<code>get_instances()</code>","text":"<pre><code>def get_instances(\n    self,\n    table_name: str,\n    version: str = constants.BASE_TABLE_VERSION,\n) -&gt; list[str]:\n</code></pre> <p>Return a list of materialised instance IDs for a specific table and version.</p> Parameter Type Description Default <code>table_name</code> <code>str</code> Name of the table. \u2013 <code>version</code> <code>str</code> Version of the table. <code>constants.BASE_TABLE_VERSION</code> <p>Returns \u2192 <code>list[str]</code> \u2013 materialised instance IDs for this table/version.</p>"},{"location":"api/core_api/#get_active_processes","title":"<code>get_active_processes()</code>","text":"<pre><code>def get_active_processes(self) -&gt; ActiveProcessDict:\n</code></pre> <p>Return a dictionary of currently active processes in the vault. Each key is a process ID and each value is metadata about that process.</p> <p>Returns \u2192 <code>ActiveProcessDict</code> \u2013 alias <code>dict[str, Mapping[str, Any]]</code>.</p>"},{"location":"api/core_api/#get_process_completion","title":"<code>get_process_completion()</code>","text":"<pre><code>def get_process_completion(self, process_id: str) -&gt; bool:\n</code></pre> <p>Return the completion status of a specific process.</p> Parameter Type Description <code>process_id</code> <code>str</code> Identifier of the process. <p>Returns \u2192 <code>bool</code> \u2013 True if the process has completed, False otherwise.</p>"},{"location":"api/core_api/#get_descriptions","title":"<code>get_descriptions()</code>","text":"<pre><code>def get_descriptions(\n    self,\n    instance_id: str = \"\",\n    table_name: str = \"\",\n) -&gt; dict:\n</code></pre> <p>Fetch the stored description metadata.</p> Parameter Type Description Default <code>instance_id</code> <code>str</code> Instance ID to describe (empty \u21d2 DB-level or table_name level). <code>\"\"</code> <code>table_name</code> <code>str</code> Table whose description is requested (ignored if <code>instance_id</code> set). <code>\"\"</code> <p>Returns \u2192 <code>dict</code> \u2013 description dictionary for the requested entity.</p>"},{"location":"api/core_api/#get_artifact_folder","title":"<code>get_artifact_folder()</code>","text":"<pre><code>def get_artifact_folder(\n    self,\n    table_name: str,\n    instance_id: str = \"\",\n    version: str = constants.BASE_TABLE_VERSION,\n    is_temp: bool = True,\n) -&gt; str:\n</code></pre> <p>Return the path to the artifact folder for a given table instance. If <code>allow_multiple_artifacts</code> is False for the <code>Table</code> and the instance is not temporary, the folder for the whole table is returned.</p> Parameter Type Description Default <code>table_name</code> <code>str</code> Name of the table. \u2013 <code>instance_id</code> <code>str</code> Table\u2011instance ID. <code>\"\"</code> <code>version</code> <code>str</code> Version string. When instance_id is omitted, fetches latest of this version. <code>constants.BASE_TABLE_VERSION</code> <code>is_temp</code> <code>bool</code> True \u21d2 path to temporary instance; False \u21d2 last materialised instance. <code>True</code> <p>Returns \u2192 <code>str</code> \u2013 path to the requested artifact folder.</p>"},{"location":"api/core_api/#get_builders_list","title":"<code>get_builders_list()</code>","text":"<pre><code>def get_builders_list(\n    self,\n    table_name: str,\n    instance_id: str = \"\",\n    version: str = constants.BASE_TABLE_VERSION,\n    is_temp: bool = True,\n) -&gt; list[str]:\n</code></pre> <p>List builder scripts stored within a specific table instance.</p> Parameter Type Description Default <code>table_name</code> <code>str</code> Target table name. \u2013 <code>instance_id</code> <code>str</code> Specific instance (empty \u21d2 latest of version). <code>\"\"</code> <code>version</code> <code>str</code> Version used when instance_id omitted. <code>constants.BASE_TABLE_VERSION</code> <code>is_temp</code> <code>bool</code> True \u21d2 look at temporary instance; False \u21d2 materialised. <code>True</code> <p>Returns \u2192 <code>list[str]</code> \u2013 names of builder scripts in the instance.</p>"},{"location":"api/core_api/#get_builder_str","title":"<code>get_builder_str()</code>","text":"<pre><code>def get_builder_str(\n    self,\n    table_name: str,\n    builder_name: str = \"\",\n    instance_id: str = \"\",\n    version: str = constants.BASE_TABLE_VERSION,\n    is_temp: bool = True,\n) -&gt; str:\n</code></pre> <p>Retrieve a stored builder script as plain text.</p> Parameter Type Description Default <code>table_name</code> <code>str</code> Table that owns the builder. \u2013 <code>builder_name</code> <code>str</code> Name of the builder file (empty \u21d2 inferred). <code>{table_name}_index</code> (converted) <code>instance_id</code> <code>str</code> Specific instance (empty \u21d2 latest of version). <code>\"\"</code> <code>version</code> <code>str</code> Version used when instance_id omitted. <code>constants.BASE_TABLE_VERSION</code> <code>is_temp</code> <code>bool</code> True \u21d2 read from temporary instance. <code>True</code> <p>Returns \u2192 <code>str</code> \u2013 full source code of the builder.</p>"},{"location":"api/core_api/#get_code_modules_list","title":"<code>get_code_modules_list()</code>","text":"<pre><code>def get_code_modules_list(self) -&gt; list[str]:\n</code></pre> <p>Return the names of code modules saved in the repository.</p> <p>Returns \u2192 <code>list[str]</code> \u2013 Python module names.</p>"},{"location":"api/core_api/#get_code_module_str","title":"<code>get_code_module_str()</code>","text":"<pre><code>def get_code_module_str(self, module_name: str) -&gt; str:\n</code></pre> <p>Return the text of a stored code module.</p> Parameter Type Description <code>module_name</code> <code>str</code> Module name (without \u201c.py\u201d). <p>Returns \u2192 <code>str</code> \u2013 module source code.</p>"},{"location":"api/core_api/#helper-functions","title":"Helper Functions","text":"<p>These functions help transport and delete a TableVault repository.</p>"},{"location":"api/core_api/#compress_vault","title":"<code>compress_vault()</code>","text":"<pre><code>def compress_vault(db_dir: str, preset: int = 6) -&gt; None:\n</code></pre> Parameter Type Description Default <code>db_dir</code> <code>str</code> Path to the TableVault directory to compress. \u2013 <code>preset</code> <code>int</code> LZMA compression level (1-9); higher is slower but smaller. <code>6</code> <p>Raises \u2192 <code>FileNotFoundError</code> \u2013 If db_dir does not exist or is not a directory.</p>"},{"location":"api/core_api/#decompress_vault","title":"<code>decompress_vault()</code>","text":"<pre><code>def decompress_vault(db_dir: str) -&gt; None:\n</code></pre> Parameter Type Description <code>db_dir</code> <code>str</code> Path to the TableVault directory (without <code>.tar.xz</code> extension, e.g., <code>my_vault</code> for <code>my_vault.tar.xz</code>). <p>Raises \u2192 <code>FileNotFoundError</code> \u2013 If the expected archive file (<code>{db_dir}.tar.xz</code>) is missing.</p>"},{"location":"api/core_api/#delete_vault","title":"<code>delete_vault()</code>","text":"<pre><code>def delete_vault(db_dir: str) -&gt; None:\n</code></pre> Parameter Type Description <code>db_dir</code> <code>str</code> Base directory of the TableVault to delete."},{"location":"api/core_cli_api/","title":"TableVault Command Line Interface","text":"<p>A convenient command-line interface for TableVault operations.</p> <p>Most sub-commands require a TableVault instance. You can provide the <code>--db-dir</code> and <code>--author</code> global options once, and they will be reused by every command invoked.</p> <p>Global Options:</p> <p>These options can be used before any subcommand.</p> Option Type Description <code>--db-dir</code> <code>PATH</code> Path to the TableVault directory (required by most commands). <code>--author</code> <code>TEXT</code> Author name used for audit logging. <code>-h, --help</code> Show the help message and exit. <p>Example:</p> <pre><code>tablevault --db-dir ./my_vault --author jinjin get-active-processes\n</code></pre>"},{"location":"api/core_cli_api/#data-creation-commands","title":"Data Creation Commands","text":"<p>These commands require the global <code>--db-dir</code> and <code>--author</code> options to be set.</p>"},{"location":"api/core_cli_api/#create-table","title":"<code>create-table</code>","text":"<pre><code>tablevault create-table &lt;TABLE_NAME&gt; [OPTIONS]\n</code></pre> <p>Create a new table definition in the vault.</p> <p>Argument:</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the new table. <p>Options:</p> Option Description Default <code>--multiple-artifacts</code> If set, each materialised instance gets its own artifact folder. Flag (False by default) <code>--side-effects</code> If set, builder files are assumed to have side effects (e.g., external API calls). Flag (False by default) <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#create-instance","title":"<code>create-instance</code>","text":"<pre><code>tablevault create-instance &lt;TABLE_NAME&gt; [OPTIONS]\n</code></pre> <p>Create a new temporary instance of a table.</p> <p>Argument:</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the table. <p>Options:</p> Option Type Description Default <code>--version</code> <code>TEXT</code> Version of the table. <code>\"\"</code> <code>--origin-id</code> <code>TEXT</code> If supplied, copy state from this existing instance ID. <code>\"\"</code> <code>--origin-table</code> <code>TEXT</code> Table associated with <code>origin-id</code>. Defaults to <code>table_name</code> if empty. <code>\"\"</code> <code>--external-edit</code> If set, this instance will be edited externally (no builder files constructed). Flag (False by default) <code>--copy</code> If set, copy from the latest materialised instance (if <code>origin-id</code> not provided). Flag (False by default) <code>--builder</code> <code>TEXT</code> Add builder names. Can be repeated for multiple builders. None (multiple) <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#create-code-module","title":"<code>create-code-module</code>","text":"<pre><code>tablevault create-code-module [OPTIONS]\n</code></pre> <p>Copy (or create) a code-module file or directory into the vault.</p> <p>Options:</p> Option Type Description Default <code>--module-name</code> <code>TEXT</code> Name for the new module. If empty, inferred from <code>copy-dir</code>. <code>\"\"</code> <code>--copy-dir</code> <code>PATH</code> Local directory or Python file to copy. If empty, a new file is created. <code>\"\"</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#create-builder-file","title":"<code>create-builder-file</code>","text":"<pre><code>tablevault create-builder-file &lt;TABLE_NAME&gt; [OPTIONS]\n</code></pre> <p>Add or update a builder (YAML) file for a temporary table instance.</p> <p>Argument:</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the table. <p>Options:</p> Option Type Description Default <code>--builder-name</code> <code>TEXT</code> File name of the builder. If empty, inferred from <code>copy-dir</code>. <code>\"\"</code> <code>--version</code> <code>TEXT</code> Version of the table. <code>base</code> <code>--copy-dir</code> <code>PATH</code> Local directory containing the builder file(s) to copy. <code>\"\"</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#instance-materialization-commands","title":"Instance Materialization Commands","text":""},{"location":"api/core_cli_api/#execute-instance","title":"<code>execute-instance</code>","text":"<pre><code>tablevault execute-instance &lt;TABLE_NAME&gt; [OPTIONS]\n</code></pre> <p>Materialise an existing temporary table instance.</p> <p>Argument:</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the table to materialise. <p>Options:</p> Option Type Description Default <code>--version</code> <code>TEXT</code> Version of the table. <code>base</code> <code>--force</code> Force a full rebuild; otherwise, attempts to reuse an origin instance. Flag (False by default) <code>--background</code> Run materialisation in a background process. Flag (False by default) <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#write-instance","title":"<code>write-instance</code>","text":"<pre><code>tablevault write-instance &lt;TABLE_NAME&gt; --csv &lt;CSV_PATH&gt; [OPTIONS]\n</code></pre> <p>Write data from a CSV file as a materialized instance of a table. The table must already have a temporary instance of the same version open for external edits.</p> <p>Argument:</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Target table. <p>Options:</p> Option Type Description Default <code>--csv</code> <code>PATH</code> Required. CSV file containing the dataframe (must exist). \u2013 <code>--version</code> <code>TEXT</code> Table version. <code>base</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed write operation.</p>"},{"location":"api/core_cli_api/#data-deletionmodification-commands","title":"Data Deletion/Modification Commands","text":"<p>These commands require the global <code>--db-dir</code> and <code>--author</code> options to be set.</p>"},{"location":"api/core_cli_api/#rename-table","title":"<code>rename-table</code>","text":"<pre><code>tablevault rename-table &lt;OLD_NAME&gt; &lt;NEW_NAME&gt; [OPTIONS]\n</code></pre> <p>Rename an existing table within the vault.</p> <p>Arguments:</p> Argument Type Description <code>OLD_NAME</code> <code>TEXT</code> Current name of the table. <code>NEW_NAME</code> <code>TEXT</code> New name for the table. <p>Options:</p> Option Description <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#delete-table","title":"<code>delete-table</code>","text":"<pre><code>tablevault delete-table &lt;TABLE_NAME&gt; [OPTIONS]\n</code></pre> <p>Permanently delete a table and all its instances (dataframes) from the vault. Metadata is retained.</p> <p>Argument:</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the table to delete. <p>Options:</p> Option Description <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#delete-instance","title":"<code>delete-instance</code>","text":"<pre><code>tablevault delete-instance &lt;TABLE_NAME&gt; &lt;INSTANCE_ID&gt; [OPTIONS]\n</code></pre> <p>Delete a materialised table instance (dataframe) from the vault. Instance metadata is retained.</p> <p>Arguments:</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the table owns the instance. <code>INSTANCE_ID</code> <code>TEXT</code> ID of the instance to delete. <p>Options:</p> Option Description <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#delete-code-module","title":"<code>delete-code-module</code>","text":"<pre><code>tablevault delete-code-module &lt;MODULE_NAME&gt; [OPTIONS]\n</code></pre> <p>Delete a code-module file (<code>{MODULE_NAME}.py</code>) from the vault.</p> <p>Argument:</p> Argument Type Description <code>MODULE_NAME</code> <code>TEXT</code> Name of the module to delete. <p>Options:</p> Option Description <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#delete-builder-file","title":"<code>delete-builder-file</code>","text":"<pre><code>tablevault delete-builder-file &lt;TABLE_NAME&gt; &lt;BUILDER_NAME&gt; [OPTIONS]\n</code></pre> <p>Remove a builder file from a temporary table instance.</p> <p>Arguments:</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the table owns the builder. <code>BUILDER_NAME</code> <code>TEXT</code> Name of the builder file to delete. <p>Options:</p> Option Type Description Default <code>--version</code> <code>TEXT</code> Version of the table. <code>base</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#process-commands","title":"Process Commands","text":"<p>These commands require the global <code>--db-dir</code> and <code>--author</code> options to be set.</p>"},{"location":"api/core_cli_api/#generate-process-id","title":"<code>generate-process-id</code>","text":"<pre><code>tablevault generate-process-id [OPTIONS]\n</code></pre> <p>Generate and return a unique process ID. This ID can be used in other operations that accept a <code>process_id</code> for persistence and restart capabilities.</p> <p>Options:</p> Option Description <code>-h, --help</code> Show this message and exit. <p>Output: Prints a new, unique process identifier.</p>"},{"location":"api/core_cli_api/#stop-process","title":"<code>stop-process</code>","text":"<pre><code>tablevault stop-process &lt;PROCESS_ID&gt; [OPTIONS]\n</code></pre> <p>Stop an active process.</p> <p>Argument:</p> Argument Type Description <code>PROCESS_ID</code> <code>TEXT</code> ID of the process to stop. <p>Options:</p> Option Description Default <code>--force</code> Force-kill the running process. Flag (False by default) <code>--materialize</code> Materialise partial instances if possible. Flag (False by default) <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the stop_process operation.</p>"},{"location":"api/core_cli_api/#data-fetching-commands","title":"Data Fetching Commands","text":"<p>These commands require the global <code>--db-dir</code> and <code>--author</code> options to be set.</p>"},{"location":"api/core_cli_api/#get-dataframe","title":"<code>get-dataframe</code>","text":"<pre><code>tablevault get-dataframe &lt;TABLE_NAME&gt; --output &lt;OUTPUT_CSV&gt; [OPTIONS]\n</code></pre> <p>Fetch a table instance and write its contents to a CSV file.</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the table. Option Type Description Default <code>--output</code> <code>PATH</code> Required. Destination CSV file path. \u2013 <code>--instance-id</code> <code>TEXT</code> Specific instance ID (empty \u21d2 latest of <code>version</code>). <code>\"\"</code> <code>--version</code> <code>TEXT</code> Table version (used if <code>instance-id</code> omitted). <code>base</code> <code>--rows</code> <code>INT</code> Limit rows fetched (<code>None</code> = no limit). <code>None</code> <code>--include-inactive</code> If set, also consider inactive instances (negates <code>active_only</code>). Flag (False by default) <code>--successful-only</code> If set, require the instance to have completed successfully. Flag (False by default) <code>--no-artifact-path</code> Skip prepending the repository path to <code>\"artifact_string\"</code> columns (<code>full_artifact_path=False</code>). Flag (False by default) <code>-h, --help</code> Show this message and exit. <p>Output: Writes the DataFrame to <code>OUTPUT_CSV</code> and prints a JSON blob containing the resolved <code>instance_id</code>, final row count, and the CSV path.</p>"},{"location":"api/core_cli_api/#get-descriptions","title":"<code>get-descriptions</code>","text":"<pre><code>tablevault get-descriptions [OPTIONS]\n</code></pre> <p>Fetch description metadata for the whole database, a single table, or a specific instance.</p> Option Type Description Default <code>--table-name</code> <code>TEXT</code> Target table (omit for DB-level). <code>\"\"</code> <code>--instance-id</code> <code>TEXT</code> Specific instance (overrides table-only). <code>\"\"</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints a JSON dictionary with the requested description(s).</p>"},{"location":"api/core_cli_api/#get-file-tree","title":"<code>get-file-tree</code>","text":"<pre><code>tablevault get-file-tree [OPTIONS]\n</code></pre> <p>Render a human-readable tree (text) of files stored in the vault.</p> Option Type Description Default <code>--table-name</code> TEXT Limit tree to a given table (optional). <code>\"\"</code> <code>--instance-id</code> TEXT Inspect a specific instance (else latest). <code>\"\"</code> <code>--code-files / --no-code-files</code> Include code modules. <code>--code-files</code> <code>--builder-files / --no-builder-files</code> Include builder scripts. <code>--builder-files</code> <code>--metadata-files / --no-metadata-files</code> Include JSON/YAML metadata. <code>--no-metadata-files</code> <code>--artifact-files / --no-artifact-files</code> Include artifact directory contents. <code>--no-artifact-files</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints the file-tree string (or RichTree render if piping into <code>rich</code> aware terminal).</p>"},{"location":"api/core_cli_api/#get-modules-list","title":"<code>get-modules-list</code>","text":"<pre><code>tablevault get-modules-list\n</code></pre> <p>List Python code modules stored in the repository.</p> Option Description <code>-h, --help</code> Show this message and exit. <p>Output: Prints a JSON list of module names.</p>"},{"location":"api/core_cli_api/#get-builders-list","title":"<code>get-builders-list</code>","text":"<pre><code>tablevault get-builders-list &lt;TABLE_NAME&gt; [OPTIONS]\n</code></pre> <p>Return the builder script names contained in a table instance.</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the table. Option Type Description Default <code>--instance-id</code> <code>TEXT</code> Specific instance (empty \u21d2 latest). <code>\"\"</code> <code>--version</code> <code>TEXT</code> Version used if <code>instance-id</code> omitted. <code>base</code> <code>--temp / --materialised</code> Inspect a temporary (<code>--temp</code>) or final (<code>--materialised</code>) copy. <code>--temp</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints a JSON list of builder filenames.</p>"},{"location":"api/core_cli_api/#get-builder-str","title":"<code>get-builder-str</code>","text":"<pre><code>tablevault get-builder-str &lt;TABLE_NAME&gt; [OPTIONS]\n</code></pre> <p>Print the source of a stored builder script.</p> Argument Type Description <code>BUILDER_NAME</code> <code>TEXT</code> Builder name (without <code>.py</code>). <code>TABLE_NAME</code> <code>TEXT</code> Table containing the builder. Option Type Description Default <code>--builder-name</code> <code>TEXT</code> Name of the builder file (empty \u21d2 inferred). <code>{table_name}_index</code> <code>--instance-id</code> <code>TEXT</code> Specific instance (empty \u21d2 latest). <code>\"\"</code> <code>--version</code> <code>TEXT</code> Version used if <code>instance-id</code> omitted. <code>constants.BASE_TABLE_VERSION</code> <code>--temp / --materialised</code> Read from temporary (<code>--temp</code>) or materialised (<code>--materialised</code>). <code>--temp</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints the full builder source code.</p>"},{"location":"api/core_cli_api/#get-code-module-str","title":"<code>get-code-module-str</code>","text":"<pre><code>tablevault get-code-module-str &lt;MODULE_NAME&gt;\n</code></pre> <p>Print the source of an arbitrary code module stored in the vault.</p> Argument Type Description <code>MODULE_NAME</code> <code>TEXT</code> Module name (without <code>.py</code>). Option Description <code>-h, --help</code> Show this message and exit. <p>Output: Prints the module\u2019s source code.</p>"},{"location":"api/core_cli_api/#vault-independent-utilities","title":"Vault-Independent Utilities","text":"<p>These commands operate on vault directories but do not require an initialized <code>TableVault</code> instance in the same way as other commands (i.e., they don't use the global <code>--author</code> for their direct operation but might be used in conjunction with a vault managed by an author).</p>"},{"location":"api/core_cli_api/#compress","title":"<code>compress</code>","text":"<pre><code>tablevault compress &lt;DB_DIR&gt; [OPTIONS]\n</code></pre> <p>Create a <code>DB_DIR.tar.xz</code> archive from the specified <code>DB_DIR</code>.</p> <p>Argument:</p> Argument Type Description <code>DB_DIR</code> <code>PATH</code> Path to the TableVault directory to compress (must exist). <p>Options:</p> Option Type Description Default <code>--preset</code> <code>INT</code> LZMA compression level (1-9). <code>6</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints a confirmation message with the name of the created archive, e.g., \"Compressed \u2192 my_vault.tar.xz\".</p>"},{"location":"api/core_cli_api/#decompress","title":"<code>decompress</code>","text":"<pre><code>tablevault decompress &lt;ARCHIVE&gt; [OPTIONS]\n</code></pre> <p>Extract a <code>*.tar.xz</code> archive (created by <code>tablevault compress</code>) into a directory named after the archive (without the <code>.tar.xz</code> extension).</p> <p>Argument:</p> Argument Type Description <code>ARCHIVE</code> <code>PATH</code> Path to the <code>*.tar.xz</code> archive file (must exist). <p>Options:</p> Option Description <code>-h, --help</code> Show this message and exit. <p>Output: Prints a confirmation message with the name of the directory where files were decompressed, e.g., \"Decompressed \u2192 my_vault/\".</p>"},{"location":"api/core_cli_api/#delete-vault","title":"<code>delete-vault</code>","text":"<pre><code>tablevault delete-vault &lt;DB_DIR&gt; [OPTIONS]\n</code></pre> <p>Irreversibly delete an entire TableVault directory. This command will ask for confirmation before proceeding.</p> <p>Argument:</p> Argument Type Description <code>DB_DIR</code> <code>PATH</code> Path to the TableVault directory to delete (must exist). <p>Options:</p> Option Description <code>--yes</code> Skip the confirmation prompt. <code>-h, --help</code> Show this message and exit. <p>Output: Prints \"Vault deleted \u2714\" upon successful deletion.</p>"},{"location":"api/table_references/","title":"Using Table References in Builder Files","text":"<p>Table References provide a powerful way to dynamically fetch and use data from other table instances, or the current table instance, directly within most string-based fields of your builder YAML files. This allows for highly dynamic and data-driven configurations.</p> <p>The <code>&lt;&lt; ... &gt;&gt;</code> syntax can be applied to any singular string, boolean or numeric entry in your builder definition, such as values in the <code>arguments</code> block, items in the <code>changed_columns</code> list, or even the <code>python_function</code> and <code>code_module</code> names themselves. The primary exception is the <code>dependencies</code> field, which does not support this dynamic resolution.</p>"},{"location":"api/table_references/#core-concept-the-wrapper","title":"Core Concept: The <code>&lt;&lt; ... &gt;&gt;</code> Wrapper","text":"<p>The fundamental syntax for a table reference is to enclose the reference string within double angle brackets: <code>&lt;&lt; ... &gt;&gt;</code>.</p> <p>Example of broad usage in a builder YAML:</p> <pre><code># In an IndexBuilder or ColumnBuilder\nbuilder_type: IndexBuilder\npython_function: \"&lt;&lt;config_table.builder_function_name[use_case::'main_index']&gt;&gt;\" # Dynamic function name\ncode_module: \"&lt;&lt;config_table.builder_module_name&gt;&gt;\" # Dynamic module name\n\nchanged_columns:\n  - \"&lt;&lt;config_table.primary_output_column&gt;&gt;\"       # Dynamic column name\n  - \"fixed_secondary_column\"\n  - \"&lt;&lt;self.another_dynamic_column_name_source[index]&gt;&gt;\" # Column name derived from self\n\narguments:\n  source_file_path: \"/data/raw/&lt;&lt;config_table.file_name[source_id::'source_A']&gt;&gt;.csv\"\n  lookup_value: \"&lt;&lt;lookup_table.value[key::&lt;&lt;self.current_key[index]&gt;&gt;]&gt;&gt;\"\n  static_text_with_ref: \"Report for ID: &lt;&lt;self.id[index]&gt;&gt;\"\n</code></pre> <p>If a field value is entirely a table reference (e.g., <code>python_function: \"&lt;&lt;config.func_name&gt;&gt;\"</code>), the resolved value of the reference will be used directly. If the reference is part of a larger string (e.g., in <code>arguments</code>), the resolved value will be converted to a string and substituted into place.</p>"},{"location":"api/table_references/#anatomy-of-a-table-reference-string","title":"Anatomy of a Table Reference String","text":"<p>Inside the <code>&lt;&lt; ... &gt;&gt;</code> wrapper, a table reference string follows a specific structure to identify the table, an optional version, specific columns, and optional filtering conditions:</p> <pre><code>tableName(version).{column1,column2,...}[condition1,condition2,...]\n</code></pre> <p>All parts (version, columns, conditions) are optional.</p> <p>Components:</p> <ol> <li><code>tableName</code>: The name of the table to query.</li> <li><code>(version)</code>: (Optional) Specifies a particular version of the table.</li> <li><code>.{columns}</code> or <code>.COLUMN</code>: (Optional) Selects specific columns.</li> <li><code>[conditions]</code>: (Optional) Filters the rows of the table.</li> </ol> <p>Let's break down each component:</p>"},{"location":"api/table_references/#1-table-name-tablename","title":"1. Table Name (<code>tableName</code>)","text":"<ul> <li>Syntax: A string of alphanumeric characters, underscores (<code>_</code>), or hyphens (<code>-</code>).</li> <li>Special Keyword <code>self</code>: The keyword <code>self</code> refers to the current table instance being processed by the builder.</li> </ul> <p><code>self</code> Keyword</p> <p>The <code>self</code> keyword cannot be be used in the <code>dtypes</code> field of a builder. The <code>dtypes</code> keyword is used when the</p> <ul> <li>Dynamic Table Name: The table name itself can be a nested table reference.<ul> <li>Example in a field: <code>code_module: \"&lt;&lt; &lt;&lt;table_map.module_column[type::'etl']&gt;&gt; &gt;&gt;\"</code></li> <li>Reference string example: <code>&lt;&lt; &lt;&lt;another_table.config_key[type::'source']&gt;&gt;.data_column &gt;&gt;</code></li> </ul> </li> </ul>"},{"location":"api/table_references/#2-version-version","title":"2. Version (<code>(version)</code>)","text":"<ul> <li>Syntax: Enclosed in parentheses, e.g., <code>(v1.0.0)</code> or <code>(prod)</code>.</li> <li>Optional: If omitted, TableVault will typically use the default or latest available version of the table based on its internal logic and cache.</li> <li>Dynamic Version: The version string can be a nested table reference.<ul> <li>Example reference string: <code>my_table(&lt;&lt;version_control_table.active_version[table_name::'my_table']&gt;&gt;)</code></li> </ul> </li> </ul>"},{"location":"api/table_references/#3-columns-columns-or-column","title":"3. Columns (<code>.{columns}</code> or <code>.COLUMN</code>)","text":"<ul> <li>Syntax:<ul> <li>Single Column: Preceded by a dot (<code>.</code>), e.g., <code>.user_id</code>.</li> <li>Multiple Columns: Preceded by a dot (<code>.</code>) and enclosed in curly braces <code>{}</code>, with column names separated by commas, e.g., <code>.{name,email,age}</code>.</li> </ul> </li> <li>Optional:<ul> <li>If omitted, and conditions are present, all columns are available for filtering, and the selected columns depend on the output simplification (see below).</li> <li>If omitted, and no conditions are present, the entire DataFrame (or its simplified form) is returned.</li> </ul> </li> <li>Dynamic Column Names: Column names within the list (or the single column name) can be nested table references. This is highly relevant for fields like <code>changed_columns</code> or <code>primary_key</code>.<ul> <li>Example in <code>changed_columns</code>: <code>changed_columns: [\"id\", \"&lt;&lt;config_table.main_data_field_name&gt;&gt;\"]</code></li> <li>Example reference string for a column name: <code>my_table.&lt;&lt;config.target_column&gt;&gt;</code></li> <li>Example reference string with multiple dynamic columns: <code>my_table.{id,&lt;&lt;audit_table.tracked_field[user::'admin']&gt;&gt;,status}</code></li> </ul> </li> <li>Special Case: <code>self.index</code>:     If you use <code>&lt;&lt;self.index&gt;&gt;</code> (assuming <code>index</code> is the name of the designated index column/concept in your TableVault constants), this specifically resolves to the current row's index value during row-wise operations or when an <code>index</code> context is available.</li> </ul>"},{"location":"api/table_references/#4-conditions-conditions","title":"4. Conditions (<code>[conditions]</code>)","text":"<ul> <li>Syntax: Enclosed in square brackets <code>[...]</code>. Multiple conditions are separated by commas <code>,</code>.</li> <li>Optional: If omitted, all rows (of the selected version and columns) are considered.</li> <li>Each condition specifies a column to filter on and the criteria.</li> </ul> <p>Condition Types:</p> <ol> <li> <p>Equality (<code>columnName::value</code>):</p> <ul> <li>Filters rows where <code>columnName</code> equals <code>value</code>.</li> <li>Example reference string: <code>orders.product_id[customer_id::'cust123',status::'shipped']</code></li> <li>The <code>value</code> is automatically quoted for string comparisons if not already quoted (e.g., <code>status::shipped</code> becomes <code>status == 'shipped'</code>). Numerical values are used directly.</li> <li><code>value</code> can be a nested table reference: <code>orders.items[user_id::&lt;&lt;user_table.id[username::'jdoe']&gt;&gt;]</code></li> </ul> </li> <li> <p>Range (<code>columnName::start_value:end_value</code>):</p> <ul> <li>Filters rows where <code>columnName</code> is greater than or equal to <code>start_value</code> AND less than <code>end_value</code>.</li> <li>Example reference string: <code>events.timestamp[timestamp::'2023-01-01T00:00:00':'2023-01-01T23:59:59']</code></li> <li><code>start_value</code> and <code>end_value</code> can be literals or nested table references. Values are formatted appropriately for comparison based on the column's data type.</li> </ul> </li> <li> <p>Implicit Index/Contextual Value (<code>columnName</code>):</p> <ul> <li>Filters rows where <code>columnName</code> equals a contextually provided <code>index</code> value (the index of the row currently being processed by the builder).</li> <li>Example: If processing row <code>101</code> of <code>self</code>, then the reference <code>&lt;&lt;other_table.data_column[join_key_in_other_table]&gt;&gt;</code> (within an argument) would attempt to find rows in <code>other_table</code> where <code>join_key_in_other_table == 101</code>.</li> <li>This is particularly useful for lookups related to the current item in <code>self</code>.</li> <li>If <code>self.some_column[key_column]</code> is used, and <code>index</code> is defined, it implies <code>self.some_column</code> where <code>key_column == index</code>.</li> </ul> </li> </ol> <p><code>index</code> Condition</p> <p>The <code>index</code> keyword can only be used in the <code>arguments</code> key of a row-wise function (when <code>row-wise</code> is set to <code>true</code>).</p> <ul> <li>Dynamic Keys and Values: All parts of a condition (the column name, the value, start/end values) can be nested table references.<ul> <li>Example reference string: <code>my_table[&lt;&lt;config.filter_column&gt;&gt;::&lt;&lt;config.filter_value&gt;&gt;]</code></li> </ul> </li> </ul>"},{"location":"api/table_references/#nested-references","title":"Nested References","text":"<p>As shown in many examples above, any component of a table reference\u2014the table name, version string, column names, condition keys, or condition values\u2014can itself be another table reference enclosed in <code>&lt;&lt; ... &gt;&gt;</code>. TableVault will resolve the innermost references first and use their results to construct the outer reference before resolving it.</p> <p>Complex Example (from code, used in an argument): <code>&lt;&lt;stories.artifact_name[paper_name::&lt;&lt;self.paper_name[index]&gt;&gt;]&gt;&gt;</code> 1.  <code>&lt;&lt;self.paper_name[index]&gt;&gt;</code>: Resolves first. It fetches the <code>paper_name</code> from the current row (<code>index</code>) of the <code>self</code> table. 2.  Let's say the above yields <code>'my_research_paper'</code>. 3.  The outer reference becomes: <code>&lt;&lt;stories.artifact_name[paper_name::'my_research_paper']&gt;&gt;</code>. 4.  This then fetches <code>artifact_name</code> from the <code>stories</code> table where <code>paper_name</code> is <code>'my_research_paper'</code>.</p>"},{"location":"api/table_references/#resolution-and-data-retrieval","title":"Resolution and Data Retrieval","text":"<ul> <li>When a builder is executed, TableVault parses these reference strings from the relevant YAML fields.</li> <li>It uses an internal cache of DataFrames (for already loaded tables and versions) to retrieve data efficiently.</li> <li>For references involving <code>self</code> or implicit index conditions, the context of the current row being processed (often an integer <code>index</code>) is crucial for resolving the correct data.</li> <li>The recursive parsing handles references within lists, dictionaries (values, and potentially keys if supported by the structure and parser), and other nested structures in the YAML, as long as they ultimately resolve to strings or collections of strings where references are found.</li> </ul>"},{"location":"api/table_references/#examples-of-reference-strings","title":"Examples of Reference Strings","text":"<p>These examples illustrate the reference string syntax itself. These strings would be placed inside <code>&lt;&lt; &gt;&gt;</code> within a suitable YAML field.</p> <ol> <li> <p>Fetch a single column from another table: <code>my_data_table.user_email</code> (When used as <code>\"&lt;&lt;my_data_table.user_email&gt;&gt;\"</code>, result: A list of all user emails from <code>my_data_table</code>, or a simplified form)</p> </li> <li> <p>Get a specific value using a filter: <code>users_table.full_name[user_id::'user-007']</code> (When used as <code>\"&lt;&lt;users_table.full_name[user_id::'user-007']&gt;&gt;\"</code>, result: The <code>full_name</code> for <code>user_id</code> 'user-007', likely a single string)</p> </li> <li> <p>Get a value from <code>self</code> based on the current row's context (implicit index): <code>self.status[id_column_of_self]</code> (When used as <code>\"&lt;&lt;self.status[id_column_of_self]&gt;&gt;\"</code>, and the current processing index is, e.g., <code>101</code>, this effectively becomes <code>self.status</code> where <code>id_column_of_self == 101</code>)</p> </li> <li> <p>Reference with a specific version: <code>app_settings(base_1748275064_5782ef5b-4023-4618-a419-cf921c365c64).timeout_ms</code></p> </li> <li> <p>Using a range condition: <code>transactions.amount[transaction_date::'2024-01-01':'2024-01-31']</code></p> </li> <li> <p>Nested reference for dynamic filtering: <code>preferences.setting_value[user_id::&lt;&lt;self.user_identifier[index]&gt;&gt;, setting_key::'theme']</code></p> </li> </ol>"},{"location":"api/table_references/#error-handling","title":"Error Handling","text":"<p>If a table reference string is malformed (e.g., unbalanced brackets, illegal characters) or if a reference cannot be resolved at runtime (e.g., table not found, column missing, nested reference fails), a <code>TableReferenceError</code> will typically be raised, halting the builder process. Ensure your references are correct and the data they point to exists.</p>"},{"location":"auxillary/about/","title":"About TableVault","text":""},{"location":"auxillary/about/#citations-and-papers","title":"Citations and Papers.","text":"<p>Feel free to read our paper to get more details about the project:</p> <ul> <li>TableVault: Managing Dynamic Data Collections for LLM-Augmented Workflows. Jinjin Zhao, and Sanjay Krishnan.</li> </ul> <p>You can cite the paper with:</p> <pre><code> # t.b.d.\n</code></pre>"},{"location":"auxillary/about/#contact","title":"Contact","text":"<p>You can reach out through email: j2zhao@uchicago.edu.</p>"},{"location":"auxillary/about/#potential-future-extensions","title":"(Potential) Future Extensions","text":"<ul> <li> <p>More Backend Options: We currently use pandas and CSV files as the backend of TableVault. While there are significant performance drawbacks to both frameworks, they were chosen due to their popularity. Alternative backends are definitively under consideration to enable more user freedom in how dataframes are stored, loaded, and queried.</p> </li> <li> <p>SQL Support (Very Likely): TableReferences were designed to be easily understandable coming from Pandas/Python indexing. However, there's a good argument that SQL queries can also be used in the same function. In practice, this shouldn't (hopefully) be that difficult to implement, and will probably be added in the future.</p> </li> <li> <p>Better Query Support: Support for queries is still relatively limited. As we explore applications of TableVault, it will become more clear how data in TableVault should be accessed.</p> </li> </ul>"},{"location":"auxillary/comparisons/","title":"Comparisons","text":""},{"location":"auxillary/comparisons/#1-tablevault-vs-sqlite","title":"1. TableVault vs. SQLite","text":""},{"location":"auxillary/comparisons/#key-differences","title":"Key Differences","text":"TableVault SQLite Native Support for Unstructured Files with Artifacts Only Supports Database Tables Transparent Data Storage Using OS File System All Tables are Stored within a single SQLite File Focus on Python Execution Only Supports SQL Executions Performance Optimizations Up to the User Internal Performance Optimizations"},{"location":"auxillary/comparisons/#summary","title":"Summary","text":"<p>TableVault is geared towards Python operations over complex, versioned datasets and artifacts, while SQLite and other traditional databases are primarily focused on SQL execution on database tables. Both TableVault and SQLite maintains data integrity and reliability by enforcing ACID principles and techniques.</p> <p>If your workflow is primarily dealing with SQL and tables, SQLite might be preferred. If you are working in data science or machine learning, you are primarily dealing with heterogeneous data, or you want exact control over execution, TableVault might be better suited for your application.</p>"},{"location":"auxillary/comparisons/#2-tablevault-vs-apache-airflow","title":"2. TableVault vs. Apache Airflow","text":""},{"location":"auxillary/comparisons/#key-differences_1","title":"Key Differences","text":"TableVault Airflow Native Support for Unstructured Files with Artifacts Does not Store Data Artifacts Can Query Data Artifacts from Different Tables DAGs are Treated as Independent Built in Logging for All Data Operations Only Logs DAG Execution Execution Scheduling up to the User Controls Scheduling of Pipelines"},{"location":"auxillary/comparisons/#summary_1","title":"Summary","text":"<p>TableVault is a lightweight execution system that is designed to ensure data integrity and transparency, and improve data reusability across different workfows. Apache Airflow is a platform to programmatically author, schedule, and monitor workflows (data pipelines). Both TableVault and Airflow track and version data transformation executions.</p> <p>If you need a tool to organize recurring executions with a rich ecosystem of custom operators, Airflow might be the right choice. If you want a Python execution system that organizes data outputs and manages metadata to improve data explainability, TableVault might make more sense for your workflow.</p>"},{"location":"auxillary/comparisons/#3-tablevauilt-vs-langchain","title":"3. TableVauilt vs. LangChain","text":""},{"location":"auxillary/comparisons/#key-differences_2","title":"Key Differences","text":"TableVault LangChain Every LLM Execution and Output is Logged No Record of Executed LLM Calls Allows Versioning of Data Artifacts No Explict Versioning Agents Interact Safely with Persistant Data Store Agents Don't Directly Write to Persistant Data General User-Defined Python Functions Specialized Suite of Custom LLM Operations"},{"location":"auxillary/comparisons/#summary_2","title":"Summary","text":"<p>Large Language models can be used with TableVault by calling the relevant API (including the <code>LangChain</code> library) or locally running the model. TableVault is complimentary to libraries such as LangChain and can be used in conjunction to organize multiple model calls, inputs and outputs. </p> <p>TableVault enables more complex language model workflows by explicitly tracking execution versions, and allowing models to safely interact with persistant artifacts that all conform to the same organization structure.</p>"},{"location":"core_concepts/execution/","title":"Builders, Code Functions, Artifacts, TableReferences","text":"<p>Builders are YAML files that serve as blueprints for creating or modifying a table instance's DataFrame. They outline the steps for an instance's execution within TableVault. Unless the instance is written externally, it has a dedicated set of builders that can be created and modified while the instance is in a temporary state. This temporary state acts as a sandbox, allowing you to define and test your builders without affecting the final, materialized version of the table. These builders are then used to materialize the instance by applying the defined transformations.</p>"},{"location":"core_concepts/execution/#1-builders","title":"1. Builders","text":""},{"location":"core_concepts/execution/#physical-folder-setup","title":"Physical Folder Setup","text":"<p>Every table instance possesses its own set of builder files. You can add builders to a temporary instance by copying them from a previous origin instance, specifying builder names during <code>create_instance</code>, or using the <code>create_builder</code> function.</p> <p></p> <p>TableVault Builders Location</p>"},{"location":"core_concepts/execution/#connecting-builders-to-code","title":"Connecting Builders to Code","text":"<p>Builders do not contain the data transformation logic themselves. Instead, they point to the Python functions that perform the actual work. This connection is established through the <code>python_function</code> and <code>code_module</code> fields in the builder's YAML file.</p> <pre><code>* `code_module`: This field specifies the Python file (e.g., `my_feature_lib`) containing the transformation function. This module must be added to TableVault using `create_code_module()`.\n* `python_function`: This is the name of the function within the `code_module` that will be executed (e.g., `build_features`). This function receives the arguments defined in the `arguments` section of the builder file.\n\nHere is a minimal example of a builder's YAML configuration:\n```yaml\n    builder_type: IndexBuilder\n\n    changed_columns: ['fruits']        # Output columns\n    primary_key: ['fruits']            # DataFrame primary key (optional)\n\n    python_function: create_data_table_from_list       # Function to execute\n    code_module: example_code                 # Module containing the function\n\n    arguments:                               # Arguments passed to the function\n        vals: ['pineapples', 'watermelons', 'coconuts']\n    is_custom: true                         #using a user-supplied function in code_module\n```\n</code></pre>"},{"location":"core_concepts/execution/#executing-an-instance","title":"Executing an Instance","text":"<p>When you execute an instance with <code>execute_instance</code>, TableVault reads the associated builder files. It begins with the <code>IndexBuilder</code> to create the initial DataFrame. Subsequently, it processes any <code>ColumnBuilder</code> files, with each calling its specified Python function to modify the DataFrame. Arguments for these functions\u2014which can be scalar values, references to other table columns (<code>&lt;&lt;TABLE.COLUMN&gt;&gt;</code>), or special keywords like <code>~ARTIFACT_FOLDER~</code>\u2014are passed from the builder file to the Python function. The execution sequence of the builders is automatically determined by the internal dependencies among the columns of the generated DataFrame (using the <code>self</code> keyword). Builder execution can be performed in a background Python process.</p>"},{"location":"core_concepts/execution/#restarting-an-execution","title":"Restarting an Execution","text":"<p>After each Python function returns a result, the output is saved within the instance folder. If the process is configured to be restartable, it will skip re-executing any steps with cached results.</p>"},{"location":"core_concepts/execution/#2-python-functions-and-the-code_function-folder","title":"2. Python Functions and the <code>code_function</code> Folder","text":""},{"location":"core_concepts/execution/#physical-folder-setup_1","title":"Physical Folder Setup","text":"<p>All user-provided Python code functions for the TableVault repository are stored in the <code>code_function</code> folder. You can create or copy files into this folder using the <code>create_code_module()</code> function. Once a file is created, it can be edited directly. During instance execution, builders retrieve the relevant function based on the specified file and function name and execute it in the same Python environment where TableVault is running.</p> <p></p> <p>TableVault Code Location</p>"},{"location":"core_concepts/execution/#code-function-specifications","title":"Code Function Specifications","text":"<p>Executed code functions can return two types of objects. If <code>row-wise</code> is <code>False</code> (the default), the function must return a pandas DataFrame containing all columns listed in <code>changed_columns</code>. If <code>row-wise</code> is <code>True</code>, the function must return a tuple of objects (or a singular object) representing one row, with all the columns specified in the <code>changed_columns</code> list. Row-wise execution is highly efficient for transformations where each row can be processed independently, such as applying a complex scoring model or making an API call for each entry.</p> <p>In the row-wise case, TableVault executes the function once per row (based on the DataFrame's state before that builder is executed) and efficiently consolidates the results using a map-reduce approach. The functions can be executed across multiple Python threads, as specified by the <code>n_threads</code> argument in the builder file.</p> <p>For successful execution, all required input arguments for the Python function must be defined in the builder file.</p> <p>While Builders and Python functions define how to generate structured DataFrame content, your analysis often involves unstructured data. TableVault addresses this through Artifacts.</p>"},{"location":"core_concepts/execution/#3-artifacts","title":"3. Artifacts","text":""},{"location":"core_concepts/execution/#_1","title":"Builders, Code Functions, Artifacts, TableReferences","text":"<p>TableVault can store data that is unsuitable for a traditional DataFrame as artifacts. An artifact can be any file, such as an image, a PDF report, a log file, a serialized model, or custom binary data, that you want to associate with your table's data. You can store artifacts at either the table level or the instance level by setting the <code>allow_multiple_artifacts</code> boolean argument during table creation. When an artifact is generated, it is first temporarily stored in the instance. After passing validation checks, TableVault moves it to permanent storage.</p> <p></p> <p>TableVault Artifact Location</p>"},{"location":"core_concepts/execution/#artifact-details","title":"Artifact Details","text":"<p>Each artifact is directly linked to a specific row in a table instance, creating an organized and powerful connection between structured data and related unstructured files.</p>"},{"location":"core_concepts/execution/#usability-of-artifacts","title":"Usability of Artifacts","text":"<p>The primary purpose of artifacts is to enrich your dataset and centralize all relevant information. Here\u2019s how they can be used:</p> <ul> <li>Machine Learning: A table of experiment results can have artifacts for each run, including saved model weights (<code>.pth</code>, <code>.h5</code>), performance charts (<code>.png</code>), configuration files (<code>.yaml</code>), or detailed logs.</li> <li>Data Analysis and Reporting: A table summarizing sales data could link to detailed PDF invoices or CSV extracts for each transaction.</li> <li>GenAI and Vision: A computer vision dataset could store the actual image or video files as artifacts linked to rows containing their metadata, labels, and features.</li> <li>General Record-Keeping: A table of product information can use artifacts to store product manuals, warranty documents, or marketing materials.</li> </ul> <p>When you retrieve data from a table using the TableVault API, you can also obtain a direct, usable file path to any associated artifact. This allows you to seamlessly load and work with these files in your code\u2014for example, displaying an image, parsing a log, or loading a model for inference\u2014without needing to manage file storage locations yourself.</p> <p>Note</p> <p>Just as Artifacts link external files to your data, TableReferences provide a dynamic way to link data from other tables directly into your builder configurations.</p>"},{"location":"core_concepts/execution/#4-tablereferences","title":"4. TableReferences","text":"<p>TableReferences enable you to dynamically pull data from any active instance to configure your builder files.</p> <p>Instead of hard-coding values in the file, you can use a special <code>&lt;&lt; ... &gt;&gt;</code> syntax to fetch information from tables, making your configurations more flexible and automated. For example, you can use a reference to:</p> <ul> <li>Pull a specific setting from a central configuration table.</li> <li>Get a list of column names to be generated.</li> <li>Look up a value from another table based on data in the current row being processed.</li> </ul> <p>You can specify which table to query, filter for specific rows, and select the exact columns you need. References can even be nested to handle complex, multi-step lookups. The system automatically retrieves the data\u2014whether it's a single value, a number, or a list\u2014and inserts it into your configuration where the reference was placed.</p>"},{"location":"core_concepts/execution/#examples","title":"Examples","text":"<p>Here is a simple example showing a TableReference within a builder's arguments: <pre><code># Example: Using a TableReference to get a configuration value\narguments:\n  model_version: '&lt;&lt;config_table.value[setting_name::'prod_model_version']&gt;&gt;'\n  api_key: '&lt;&lt;secrets_table.key[service::'external_api']&gt;&gt;'\n</code></pre></p>"},{"location":"core_concepts/operations/","title":"Operations","text":"<p>Every write operation to the TableVault repository follows a multi-step, managed process designed for safety and recoverability. Orchestrated by the main <code>tablevault_operation</code> function, this process involves distinct setup, execution, and takedown phases. This structure ensures the database remains in a consistent state, even if an operation is interrupted by errors or external factors.</p> <p>All operations that follow this pattern allow the user to include an optional <code>process_id</code> string, which uniquely identifies the operation to the system.</p>"},{"location":"core_concepts/operations/#process-ids-pauses-and-restarts","title":"Process IDs, Pauses, and Restarts","text":"<p>Each write operation in TableVault is identified by a unique <code>process_id</code> string. This ID is either provided by the user or generated internally by the system. A user can provide their own <code>process_id</code> by first creating one with the <code>generate_process_id</code> function from the core API. You can observe active operations using the <code>get_active_processes()</code> function.</p> <p>The behavior of an interrupted operation depends on whether a <code>process_id</code> was provided:</p> <ul> <li> <p>Without a user-provided <code>process_id</code>, if an operation encounters an unexpected error or is externally interrupted (e.g., by killing a Jupyter notebook cell), it is safely reverted. The system state will be as if the operation never started.</p> </li> <li> <p>With a user-provided <code>process_id</code>, an interruption only pauses the operation. It maintains its system locks, preventing other operations from accessing the same resources. Users can restart the exact same operation by re-running the function call with the same <code>process_id</code> or by setting <code>restart=True</code> in a new TableVault object. This is especially useful for long-running <code>execute_instance</code> operations that might be stopped. Note that the operation restarts from its last checkpoint, and its input arguments cannot be changed.</p> </li> </ul> <p>To explicitly stop and revert an active process, you can call the <code>stop_process</code> function. Internal TableVault errors, which typically indicate invalid user inputs, will always cause the operation to revert.</p> <p>A record of all completed processes can be found in the <code>TABLEVAULT_NAME/metadata/logs.txt</code> file.</p>"},{"location":"core_concepts/operations/#the-core-transactional-steps","title":"The Core Transactional Steps","text":"<p>Each write operation follows a series of universal, transactional steps:</p> <ol> <li> <p>Process Initialization: TableVault generates a unique <code>process_id</code> if one is not provided. If an ID is given, the system checks for existing logs associated with it. This allows a failed or paused operation to be resumed from where it left off.</p> </li> <li> <p>Setup Phase: An operation-specific setup function runs to prepare for the main task. It is responsible for:</p> <ul> <li>Validation: Checking for illegal arguments, such as attempting to modify a protected table.</li> <li>Locking: Acquiring exclusive and shared locks on the necessary resources to prevent conflicts during multi-processing.</li> <li>Creating a Backup: Copying the data to be modified into a temporary location. This is critical for recovery.</li> <li>Passing Arguments: Preparing and returning the arguments needed for the main execution function.</li> </ul> </li> <li> <p>Execution Phase: If the setup is successful, the main operation function is called. The system supports background execution for <code>execute_instance()</code> calls by spawning a new Python process, which allows the main program to continue without waiting.</p> </li> <li> <p>Takedown Phase: After execution finishes, an operation-specific takedown function cleans up the process:</p> <ul> <li>On Success: The function removes the locks, signifying that the operation is complete and the data is in its new, consistent state. It then removes the temporary backup.</li> <li>On Failure: The function uses the temporary backup to restore the original data, effectively rolling back any changes.</li> <li>Cleanup: In either case, it releases all locks held by the process and deletes temporary data.</li> </ul> </li> <li> <p>Logging: Throughout this entire process, the operation's status (e.g., start, success, errors) is logged to persistent storage, making the system resilient.</p> </li> </ol>"},{"location":"core_concepts/operations/#example-the-delete-operation","title":"Example: The Delete Operation","text":"<p>The <code>setup_delete_instance</code> and <code>takedown_delete_instance</code> functions provide a concrete example of this process.</p> <ul> <li> <p>Setup (<code>setup_delete_instance</code>):</p> <ol> <li>Validates that the table and the specific instance to be deleted both exist.</li> <li>Acquires an exclusive lock on that table and instance ID.</li> <li>Copies the instance to a temporary directory associated with the <code>process_id</code>.</li> <li>Updates the process log with the <code>table_name</code> and <code>instance_id</code> so the takedown function knows what to clean up.</li> </ol> </li> <li> <p>Takedown (<code>takedown_delete_instance</code>):</p> <ol> <li>If the main deletion logic failed, it copies the data from the temporary directory back to its original location, undoing any partial changes.</li> <li>If the main deletion logic succeeded, it simply deletes the temporary backup and lock files.</li> <li>Finally, it releases all of its locks.</li> </ol> </li> </ul> <p>In essence, TableVault's write operations are transactional. Through a combination of locking, temporary data backups, and detailed process logging, they ensure that an operation either completes successfully, leaving the repository in a new consistent state, or it fails and the repository is returned to the state it was in before the operation began.</p>"},{"location":"core_concepts/structure/","title":"Repository Structure","text":""},{"location":"core_concepts/structure/#1-tablevault-repository","title":"1. TableVault Repository","text":"<p>Everything in a TableVault repository is stored and organized transparently within your local file system. This allows you to directly view all your data and the exact execution code using any interface application you prefer. Additionally, transferring your TableVault workflow to a new device is as simple as copying the relevant TableVault folder and setting up the same environment.</p> <p>However, it is crucial to note that most writes to a TableVault folder must be done through the API to avoid breaking the system.</p> <p>!!! note \"Builders and Code Files\" Builders and Python code files are the only two cases where direct edits using an external editor are permitted.</p> <p>!!! note \"Unix Systems\" On Unix systems, we have set some files in TableVault to read-only to make this restriction more explicit. While this does not prevent malicious users, it can help prevent unintentional mistakes.</p>"},{"location":"core_concepts/structure/#physical-folder-setup","title":"Physical Folder Setup","text":"<p>The following diagram illustrates the internal storage structure of a TableVault repository:</p> <p></p> <p>TableVault File Structure</p>"},{"location":"core_concepts/structure/#2-tablevault-instance","title":"2. TableVault Instance","text":"<p>A TableVault instance represents a dataframe with its associated metadata and optional artifacts. Physically, all files relevant to an instance are stored in a dedicated instance folder.</p> <p>There are two types of instances:</p> <p>Temporary Instance. This type of instance has not yet been executed and cannot be queried by the system. A temporary instance is created with the <code>create_instance</code> operation and contains various data, such as metadata, a description, and builder files (YAML files that specify how to construct the dataframe). You can specify whether an instance will be executed within the TableVault framework or populated from an external dataframe by using the <code>external_edit</code> parameter in the <code>create_instance</code> operation. If <code>external_edit</code> is set to <code>False</code>, the instance is prepared for execution using its internal builder files. If set to <code>True</code>, the instance is marked to be populated by an external process.</p> <p>Materialized Instance. This type of instance has been executed (either by the system or externally) and is indexed by TableVault. The dataframe within a materialized instance is read-only; it can be deleted but not modified. If the instance is active (as determined by table properties), you can fetch its associated dataframe and select metadata using the TableVault API. The code functions and builder files used at execution are recorded where relevant. Materialized instances within the same table are versioned by a timestamp and, optionally, a user-specified <code>version</code> string.</p>"},{"location":"core_concepts/structure/#3-table-folder","title":"3. Table Folder","text":"<p>In TableVault, a \"table\" is more of a semantic abstraction than a concrete object. It is a collection of TableVault instances that can be referenced by the same name. All instances are encapsulated within a containing folder. In many TableVault API functions, the latest instance of a collection can be retrieved or queried using only the <code>table_name</code> reference, rather than its <code>instance_id</code>. In your file system, all instances belonging to the same table are stored together in the same folder.</p> <p>Instances under the same table can share additional properties. During table initialization, if <code>allow_multiple_artifacts</code> is set to <code>False</code>, only the latest instance can be queried by TableVault, and only its indexed artifacts are stored. This is useful when you only want one active version of an artifact collection. If <code>has_side_effects</code> is set to <code>True</code>, all other instances of the same table become un-queryable the moment one instance begins execution. This is useful if your program performs an action that invalidates previous instances, such as changing the state of external storage.</p> <p>Examples of tables include: a collection of instances testing different prompts for the same task, an instance tracking a repository of scientific papers, or evolving instances of an embedding model trained on different documents. You can add a free-form text description of a table by filling in the <code>description</code> argument in the <code>create_table</code> function.</p>"},{"location":"core_concepts/structure/#4-metadata","title":"4. Metadata","text":"<p>A TableVault repository stores various metadata files. A detailed list of these files and their functions can be found in the Advanced section.</p>"},{"location":"examples/api_call_example/","title":"Short Stories Q&amp;A with OpenAI","text":"<p>Check out: OpenAI Short Stories Colab Notebook</p>"},{"location":"examples/local_embeddings_example/","title":"GritLM Embeddings from Scientific Abstracts","text":"<p>Check out: GritLM Embeddings Colab Notebook</p>"},{"location":"workflows/errors/","title":"Handling Execution Errors","text":"<p>TableVault is designed so that each write operation is transactional, and has a robust error-handing procedure.</p>"},{"location":"workflows/errors/#1-unexpected-errors-without-process_id","title":"1. Unexpected Errors without <code>process_id</code>","text":"<p>If an operation encounters an unexpected error, it is safely reverted. The system state will be as if the operation never started.</p> <p>Executing Instances</p> <p>Partially executed dataframes are not reverted for debugging purposes. However, if you rerun the <code>execute_instance</code> operation, the full dataframe is rebuilt. After an error, in this case, you can still directly edit the <code>builder</code> and <code>code_function</code> files, as if the instance hasn't executed.</p>"},{"location":"workflows/errors/#example-code","title":"Example Code","text":"1. Initial Code2. Example Error3. Rerun Code <pre><code>tablevault.execute_instance(table_name = 'openai_responses')\n</code></pre> <pre><code>openai.error.APIConnectionError: HTTPSConnectionPool(\n    host='api.openai.com',\n    port=443\n): Max retries exceeded with url: /v1/chat/completions\n(Caused by NewConnectionError('Temporary failure in name resolution'))\n</code></pre> <pre><code># re-execute the command\ntablevault.execute_instance(table_name = 'openai_responses')\n# restarts from beginning\n</code></pre>"},{"location":"workflows/errors/#2-external-tablevault-errors-with-process_id-and-system-interrupts","title":"2. External TableVault Errors with <code>process_id</code> and System Interrupts","text":"<p>With a user-provided <code>process_id</code>, an error only pauses the operation. It maintains its system locks, preventing other operations from accessing the same resources.  This is especially useful for long-running <code>execute_instance</code> operations that might be stopped. </p> <p>This is also true if the program is externally interrupted (e.g., by killing a Jupyter notebook cell).</p> <p>Note that the operation restarts from its last checkpoint, and its input arguments cannot be changed.</p>"},{"location":"workflows/errors/#example-code_1","title":"Example Code","text":"1. Initial Code2. Example Error3. Rerun Code <pre><code># generate process_id\nprocess_id = tablevault.generate_process_id()\n# execute process\ntablevault.execute_instance(table_name = 'openai_responses', process_id = process_id)\n</code></pre> <pre><code>openai.error.APIConnectionError: HTTPSConnectionPool(\n    host='api.openai.com',\n    port=443\n): Max retries exceeded with url: /v1/chat/completions\n(Caused by NewConnectionError('Temporary failure in name resolution'))\n</code></pre> <pre><code># re-execute the command with the SAME process_id\ntablevault.execute_instance(table_name = 'openai_responses', process_id = process_id)\n# restarts from checkpoint\n</code></pre>"},{"location":"workflows/errors/#restart-process","title":"Restart Process","text":"<p>You can restart the exact same operation by re-running the function call with the same <code>process_id</code> or by setting <code>restart=True</code> in a new TableVault object. In the latter case, we assume a system crash, and all currently active processes restarted.</p>"},{"location":"workflows/errors/#example-code_2","title":"Example Code","text":"<pre><code>tablevault = TableVault(db_dir = 'stories_tv', restart = True)\n</code></pre>"},{"location":"workflows/errors/#stop-process","title":"Stop Process","text":"<p>To explicitly stop and revert an active process, you can call the <code>stop_process</code> function. If you want to materialize the partially generated dataframe, you can set the <code>materialize</code> boolean argument. The dataframe becomes an active materialized instance, but its artifacts do not overwrite pre-existing artifacts.</p>"},{"location":"workflows/errors/#example-code_3","title":"Example Code","text":"<pre><code># materialize only applies to `execute_instance()` operations\ntablevault.stop_process(process_id = process_id, materialize = True)\n</code></pre>"},{"location":"workflows/errors/#3-internal-tablevault-errors","title":"3. Internal TableVault Errors","text":"<p>Internal TableVault errors, regardless of <code>process_id</code>, will always cause the operation to revert. These errors typically indicate that some user input is invalid and need to be fixed.</p>"},{"location":"workflows/errors/#example-code_4","title":"Example Code","text":"<p>There are certain keywords that cannot be used for <code>table_name</code>:</p> 1. Initial Code2. Example Error3. Rerun Code <pre><code>tablevault.make_table(table_name = 'artifacts')\n</code></pre> <pre><code>tv_errors.TVArgumentError: Forbidden Table Name: artifacts\n</code></pre> <pre><code>tablevault.make_table(table_name = 'short_stories_store')\n</code></pre>"},{"location":"workflows/workflow/","title":"Basic Workflow","text":"<p>The TableVault API allows users to generate and execute instances of data tables through a straightforward workflow. The process begins with establishing a central repository, followed by defining the structure of a table, creating specific instances of that table, and then using builder files to populate and materialize the data.</p>"},{"location":"workflows/workflow/#1-make-a-repository","title":"1. Make a Repository","text":"<pre><code>tablevault = TableVault(db_dir = \"test_tv\", author = \"kong\", create = True,\n    description = \"this is an example repository.\")\n</code></pre>"},{"location":"workflows/workflow/#2-make-a-table","title":"2. Make a Table","text":"<pre><code>tablevault.create_table(table_name = \"fruits_table\", \n    description = \"this is an example table.\")\n</code></pre>"},{"location":"workflows/workflow/#3-make-a-table-instance","title":"3. Make a Table Instance","text":"<pre><code>tablevault.create_instance(table_name = \"fruits_table\")\n</code></pre>"},{"location":"workflows/workflow/#4-write-the-code-files","title":"4. Write the Code Files","text":"<pre><code>tablevault.create_code_module(module_name = \"example_code\")\n</code></pre> <p>Example Code</p> <p>You can fill out the code file with the following code:</p> <pre><code>import pandas as pd\n\ndef create_data_table_from_list(vals: list[str]):\n    return pd.DataFrame({\"temp_name\": vals})\n</code></pre> <p>If you don't have direct access to a text editor on your platform, you can add the code as a string argument, <code>text</code>, in <code>create_code_module</code>.</p>"},{"location":"workflows/workflow/#4-write-the-builder-files","title":"4. Write the Builder Files","text":"<pre><code>tablevault.create_builder_file(table_name = \"fruits_table\", builder_name = \"fruits_table_index\")\n</code></pre> <p>Example Builder</p> <p>You can fill out the builder file with the following text:</p> <pre><code>builder_type: IndexBuilder\n\nchanged_columns: ['fruits']        # Output columns\nprimary_key: ['fruits']            # DataFrame primary key (optional)\n\npython_function: create_data_table_from_list       # Function to execute\ncode_module: example_code                 # Module containing the function\n\narguments:                               # Arguments passed to the function\n    vals: ['pineapples', 'watermelons', 'coconuts']\nis_custom: true                         #using a user-supplied function in code_module\n</code></pre> <p>If you don't have direct access to a text editor on your platform, you can add the code as a string argument, <code>text</code>, in <code>create_builder_file</code>.</p>"},{"location":"workflows/workflow/#5-materialize-the-instance","title":"5. Materialize the Instance","text":"<pre><code>tablevault.execute_instance(table_name = \"fruits_table\")\n</code></pre>"},{"location":"workflows/workflow/#6-create-a-second-instance","title":"6. Create a Second Instance","text":"<p>There are two different ways, you can create a second instance of the <code>fruits_table</code> table.</p>"},{"location":"workflows/workflow/#1-copying-previous-instances","title":"1. Copying Previous Instances","text":"<p>To make building the dataframe easier, you can copy the metadata of the last materialized instance:</p> <pre><code>tablevault.create_instance(table_name = \"fruits_table\", copy = True)\n</code></pre> <p>You simply need to change one line in the <code>fruits_table_index.YAML</code> file:</p> <pre><code>arguments:                               # Arguments passed to the function\n    vals: ['bananas']\n</code></pre> <p>You then can execute normally:</p> <pre><code>tablevault.execute_instance(table_name = \"fruits_table\")\n</code></pre>"},{"location":"workflows/workflow/#2-externally-writing-instances","title":"2. Externally Writing Instances","text":"<p>If you want to edit the dataframe outside of the TableVault library (not generally recommended), you can explicitly declare this when generating the new instance: </p> <pre><code>tablevault.create_instance(table_name = \"fruits_table\", external_edit = True,\n    description=\"externally created dataframe\")\n</code></pre> <p>You can now write a new dataframe directly into our table:</p> <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'fruits': ['bananas']})\n\ntablevault.write_instance(df, table_name = \"fruits_table\")\n</code></pre>"},{"location":"workflows/workflow/#7-query-for-a-dataframe","title":"7. Query for A Dataframe","text":"<p>You can easily retrieve the dataframe of both instances: </p> <pre><code>instances = tablevault.get_instances(table_name = \"fruits_table\")\n\ndf_1 = tablevault.get_dataframe(table_name = \"fruits_table\", instance_id = instances[0])\ndf_2 = tablevault.get_dataframe(table_name = \"fruits_table\")\n</code></pre> <p>The dataframes should have the expected values:</p> df_1df_2 <pre><code>    fruits\n0   pineapples\n1   watermelons\n2   coconuts\n</code></pre> <pre><code>    fruits\n0   bananas\n</code></pre>"},{"location":"workflows/workflow_artifacts/","title":"Workflow with Artifacts","text":"<p>In TableVault, an artifact is any file that isn't a dataframe. Every artifact must be linked to a specific table instance and indexed with a reference within the corresponding dataframe. This connection is established by the user through builders and Python functions.</p>"},{"location":"workflows/workflow_artifacts/#1-creating-an-artifact-table-and-instance","title":"1. Creating an Artifact Table and Instance","text":"<p>You can start with the <code>TableVault</code> repository generated with the Basic Workflow.</p> <pre><code>tablevault = TableVault(db_dir = \"test_tv\", author = \"dixie\")\ntablevault.create_table(table_name = \"fruit_images\", allow_multiple_artifacts = False)\ntablevault.create_instance(table_name = \"fruit_images\")\n</code></pre> <p>Setting <code>allow_multiple_artifacts</code> to <code>False</code> tells the system that we will only have one artifact repository for the whole folder.</p>"},{"location":"workflows/workflow_artifacts/#2-a-code-function-that-generates-artifacts","title":"2. A Code Function that Generates Artifacts","text":"<pre><code>tablevault.create_code_module(module_name = \"fetch_images\")\n</code></pre> <p>You can fill out the code file to import an image, given a type of fruit:</p> <pre><code>import shutil\n\ndef fetch_image_from_string(fruit: str, artifact_dir:str ):\n    file_path = f'./all_images/{fruit}.png' # pre-existing file\n    new_file_path = f'{artifact_dir}/{fruit}.png'\n\n    shutil.copy(file_path, new_file_path)\n\n    return f'{fruit}.png' # return relative path\n</code></pre> <p>If you don't have direct access to a text editor on your platform, you can add the code as a string argument, <code>text</code>, in <code>create_code_module</code>.</p> <p>Executing the Example</p> <p>In order for your code to actually execute, an actual image needs to exist in the  <code>file_path</code> location.</p>"},{"location":"workflows/workflow_artifacts/#3-a-builder-with-artifact_string","title":"3. A Builder with <code>~ARTIFACT_STRING~</code>","text":"<pre><code>tablevault.create_builder_file(\"fruit_images_index\")\ntablevault.create_builder_file(\"fetch_image_artifact\")\n</code></pre> fruit_images_index.yamlfetch_image_artifact.yaml <pre><code>builder_type: IndexBuilder\n\nchanged_columns: ['fruits']        # Output columns\nprimary_key: ['fruits']            # DataFrame primary key (optional)\n\npython_function: create_data_table_from_table           # Function to execute\ncode_module: table_generation                 # Module containing the function\n\narguments:                               # Arguments passed to the function\n    df: &lt;&lt;fruit_table.fruits&gt;&gt;                  \n</code></pre> <pre><code>builder_type: ColumnBuilder\n\nchanged_columns: ['fruit_image']                        # Output columns\n\npython_function: create_data_table_from_table           # Function to execute\ncode_module: table_generation                           # Module containing the function\n\nis_custom: true                                         # Mark as user-supplied (searches in code_functions)\nreturn_type: row-wise                                       # Specifies if the function processes row by row\n\narguments:                                              # Arguments passed to the function\n    fruit: &lt;&lt;self.fruits[index]&gt;&gt; \n    artifact_dir: ~ARTIFACT_FOLDER~ \n\ndtypes:                                                 # Column Data Types \n    fruit_image: artifact_string            \n</code></pre> <p>The <code>~ARTIFACT_FOLDER~</code> keyword is automatically replaced with the correct folder path at runtime. The <code>artifact_string</code> data type tells the system that the <code>fruit_image</code> column is linked to artifacts. </p> <p>Each artifact file needs a corresponding <code>artifact_string</code> value in the dataframe. This value is the file path of the artifact, relative to the temporary artifact folder. This is user-generated (as seen in the <code>fetch_image_from_string()</code> function).</p> <p>You can see examples of <code>TableReference</code> strings with <code>&lt;&lt;fruit_table.fruits&gt;&gt;</code> and <code>&lt;&lt;self.fruits[index]&gt;&gt;</code>. The first string returns a column in the lastest <code>fruit_table</code> dataframe. The second string returns a string corresponding to the current index value from the <code>fruits</code> column of the executing dataframe.</p> <p>If you don't have direct access to a text editor on your platform, you can add the code as a string argument, <code>text</code>, in <code>create_code_module</code>.</p>"},{"location":"workflows/workflow_artifacts/#4-execute-and-materialize-instance","title":"4. Execute and Materialize Instance","text":"<pre><code>tablevault.execute_instance(\"fruit_image\")\n</code></pre> <p>Strict Checks</p> <p>Various checks are performed before the table is materialized to ensure everything is configured correctly. Most importantly, each <code>artifact_string</code> value must have a corresponding artifact file and vice versa.</p> <p>Once materialized, the artifact is moved to a permanent location associated with the materialized instance.</p>"},{"location":"workflows/workflow_artifacts/#5-query-for-an-artifact-dataframe","title":"5. Query for An Artifact Dataframe","text":"<p>You can easily retrieve the dataframe with the full or partial artifact path: </p> <pre><code>df_1 = tablevault.get_dataframe(table_name = \"fruits_table\", full_artifact_path = True)\ndf_2 = tablevault.get_dataframe(table_name = \"fruits_table\", full_artifact_path = False)\n</code></pre> <p>The dataframes should have the expected values:</p> df_1df_2 <pre><code>   fruits     fruit_image\n0  bananas    test_tv/fruit_image/artifacts/bananas.png\n</code></pre> <pre><code>   fruits     fruit_image\n0  bananas    bananas.png\n</code></pre>"}]}