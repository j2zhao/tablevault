{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to TableVault","text":"<p>TableVault is designed to manage data tables and artifacts in complex and dynamic data workflows. It promotes data reusability by capturing the full context of data transformations and ensuring atomic and transactional data states\u2014transformations either clearly succeed or fail. It enhances data interoperability by easily connecting previous results with the configuration and input variables of subsequent transformations.</p> <p>TableVault integrates with Python and can be used with popular data science libraries and tools, including Jupyter Notebooks, Pandas, NumPy, Transformers, and many others. The tool is particularly effective for workflows involving multiple dataframes, external artifacts (e.g., images, videos, documents), and large language model executions. TableVault is suited for agentic pipelines since one data-generating process can easily spin additional subprocesses.</p> <p>Installation via pip:</p> <pre><code>pip install \"git+https://github.com/j2zhao/tablevault.git\"\n</code></pre> <p>This library is fully compatible with <code>Python&gt;=3.11</code>.</p> <p>Note: An official release to the Python Package Index is scheduled for July 2025.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<p>Check out Basic Workflow for a simple generic setup, and our Colab examples (1) Short Stories Q&amp;A with OpenAI and  (2) GritLM Embeddings from Scientific Abstracts for concrete use cases.</p> <p>To understand the basics of TableVault, read through the Core Concepts</p>"},{"location":"advanced/comparisons/","title":"Comparisons","text":"<p>To understand the use cases of TableVault further, we compare it to some popular data science tools.</p>"},{"location":"advanced/comparisons/#tablevault-vs-sqlite","title":"TableVault vs. SQLite","text":""},{"location":"advanced/comparisons/#key-differences","title":"Key Differences","text":"TableVault SQLite Native Support for Unstructured Files with Artifacts Only Supports Database Tables Transparent Data Storage Using the OS File System All Tables are Stored Within a Single SQLite File Focus on Python Execution Only Supports SQL Execution Performance Optimizations Are Up to the User Internal Performance Optimizations"},{"location":"advanced/comparisons/#summary","title":"Summary","text":"<p>TableVault is geared towards Python operations over complex, versioned datasets and artifacts, while SQLite and other traditional databases are primarily focused on SQL execution on database tables. Both TableVault and SQLite maintain data integrity and reliability by enforcing ACID principles and techniques.</p> <p>If your workflow primarily deals with SQL and tables, SQLite might be preferred. If you work in data science or machine learning, deal with heterogeneous data, or want exact control over execution, TableVault might be better suited for your application.</p>"},{"location":"advanced/comparisons/#tablevault-vs-apache-airflow","title":"TableVault vs. Apache Airflow","text":""},{"location":"advanced/comparisons/#key-differences_1","title":"Key Differences","text":"TableVault Airflow Native Support for Unstructured Files with Artifacts Does Not Store Data Artifacts Can Query Data Artifacts from Different Tables DAGs are Treated as Independent Built-in Logging for All Data Operations Only Logs DAG Execution Execution Scheduling Is Up to the User Controls Scheduling of Pipelines"},{"location":"advanced/comparisons/#summary_1","title":"Summary","text":"<p>TableVault is a lightweight execution system designed to ensure data integrity and transparency and improve data reusability across different workflows. Apache Airflow is a platform to programmatically author, schedule, and monitor workflows (data pipelines). Both TableVault and Airflow track and version data transformation executions.</p> <p>If you need a tool to organize recurring executions with a rich ecosystem of custom operators, Airflow might be the right choice. If you want a Python execution system that organizes data outputs and manages metadata to improve data explainability, TableVault might make more sense for your workflow.</p>"},{"location":"advanced/comparisons/#tablevault-vs-langchain","title":"TableVault vs. LangChain","text":""},{"location":"advanced/comparisons/#key-differences_2","title":"Key Differences","text":"TableVault LangChain Every LLM Execution and Output Is Logged No Record of Executed LLM Calls Allows Versioning of Data Artifacts No Explicit Versioning Agents Interact Safely with a Persistent Data Store Agents Don't Directly Write to Persistent Data General, User-Defined Python Functions Specialized Suite of Custom LLM Operations"},{"location":"advanced/comparisons/#summary_2","title":"Summary","text":"<p>Large language models can be used with TableVault by calling the relevant API (including the <code>LangChain</code> library) or by locally running the model. TableVault is complementary to libraries such as LangChain and can be used in conjunction to organize multiple model calls, inputs, and outputs.</p> <p>TableVault enables more complex language model workflows by explicitly tracking execution versions and allowing models to safely interact with persistent artifacts that all conform to the same organizational structure.</p>"},{"location":"advanced/metadata/","title":"Metadata Documentation","text":"<p>This document describes the various metadata files generated by a TableVault repository to track table states and transformations. </p> <p>While these files should never be manually modified by users, they provide essential insights into the repository's internal state. Below is a detailed explanation of each metadata file type and its contents.</p>"},{"location":"advanced/metadata/#general-metadata","title":"General Metadata","text":""},{"location":"advanced/metadata/#metadatalogstxt-and-metadatalog_idstxt","title":"<code>metadata/logs.txt</code> and <code>metadata/log_ids.txt</code>","text":"<p>These files record information about completed logs. <code>logs.txt</code> includes comprehensive details, whereas <code>log_ids.txt</code> only lists the <code>process_id</code>.</p>"},{"location":"advanced/metadata/#metadataactive_logsjson","title":"<code>metadata/active_logs.json</code>","text":"<p>This file stores details about all currently active processes. Users can directly query this data through the TableVault API.</p>"},{"location":"advanced/metadata/#metadatatables_historyjson-metadatacolumns_historyjson-and-metadatatables_tempjson","title":"<code>metadata/tables_history.json</code>, <code>metadata/columns_history.json</code>, and <code>metadata/tables_temp.json</code>","text":"<p>These files maintain a historical record of all fully stored table instances:</p> <ul> <li> <p><code>tables_history.json</code> records:</p> </li> <li> <p>When a dataframe was first created (potentially by a different table instance).</p> </li> <li>When an instance was initially materialized.</li> <li> <p>When an instance ceased to be active.</p> </li> <li> <p><code>columns_history.json</code> tracks creation at the column level.</p> </li> <li> <p><code>tables_temp.json</code> records temporary table instances.</p> </li> </ul> <p>These files are used internal operations, optimization strategies, and historical tracking.</p>"},{"location":"advanced/metadata/#locks","title":"<code>locks/*</code>","text":"<p>TableVault implements custom file-based read-write locks to enable multiprocessing capabilities.</p>"},{"location":"advanced/metadata/#_temp","title":"<code>_temp/*</code>","text":"<p>This directory temporarily stores previous file states during active operations. If an operation fails, it allows safe restoration of the repository's previous state.</p>"},{"location":"advanced/metadata/#metadataarchived_trash","title":"<code>metadata/ARCHIVED_TRASH/*</code>","text":"<p>Upon deletion of tables and instances, their dataframes and artifacts are removed, but the associated metadata is archived in this folder. This feature preserves historical context.</p> <p>Note</p> <p>Files within this folder can safely be deleted if storage space is limited. Typically, these files occupy minimal space.</p>"},{"location":"advanced/metadata/#locklock-file","title":"<code>lock.LOCK</code> file","text":"<p>This lock file ensures exclusive write access to the repository metadata, preventing concurrent write operations.</p>"},{"location":"advanced/metadata/#tablevault-file","title":"<code>.tablevault</code> file","text":"<p>This file identifies the directory explicitly as a TableVault repository.</p>"},{"location":"advanced/metadata/#table-and-instance-metadata","title":"Table and Instance Metadata","text":""},{"location":"advanced/metadata/#descriptionsyaml","title":"<code>descriptions.yaml</code>","text":"<p>Each TableVault repository, table, and instance has a dedicated YAML file containing specific metadata. While some metadata is automatically generated, users can include optional free-form descriptions during creation. This capability allows arbitrary contextual details to be preserved.</p>"},{"location":"advanced/metadata/#dtypesjson","title":"<code>dtypes.json</code>","text":"<p>For each materialized instance, a <code>dtypes.json</code> file specifies the data types of all columns. This is particularly useful for managing custom data types and tracking <code>artifact_string</code> columns.</p>"},{"location":"advanced/metadata/#execution_archive-folder","title":"<code>EXECUTION_ARCHIVE/*</code> folder","text":"<p>Each executed instance contains an <code>EXECUTION_ARCHIVE</code> folder, explicitly documenting the Python functions executed during the instance's lifecycle.</p>"},{"location":"advanced/os/","title":"Operating System Differences","text":"<p>Due to underlying file system differences, TableVault exhibits distinct behaviors on Windows and external drives in the following ways:</p> <ul> <li> <p>The <code>metadata/lock.LOCK</code> file does not persist on Windows. This behavior is due to the implementation specifics of the underlying <code>filelock</code> library.</p> </li> <li> <p>Files are never marked as read-only on Windows or external drives (e.g., mounted Google Drive on Colab). Users must exercise additional caution to prevent unintended overwrites.</p> </li> <li> <p>Temporary files are copied rather than hardlinked when using external drives. This copying mechanism can lead to reduced performance in these environments.</p> </li> </ul>"},{"location":"api/builders/","title":"Builder and Custom Function Guide","text":"<p>Builders inform TableVault how to build a DataFrame upon instance execution. Builder files are YAML specifications that define how a table instance is constructed or modified.</p>"},{"location":"api/builders/#builder-file-configuration","title":"Builder File Configuration","text":"<p>TableVault supports two built-in builder types:</p> <ol> <li><code>IndexBuilder</code>: Produces a new DataFrame, often by defining its primary key and core rows.</li> <li><code>ColumnBuilder</code>: Generates or mutates individual columns within the DataFrame established by the <code>IndexBuilder</code>.</li> </ol> <p>Each table instance that is executed must contain exactly one <code>IndexBuilder</code>. Additional <code>ColumnBuilder</code> files can be included to perform subsequent modifications.</p> IndexBuilderColumnBuilder <p>An <code>IndexBuilder</code> is used to produce the initial DataFrame for a table instance. It typically defines the primary structure, index, and the total set of rows, often involving operations like joins or initial data loading.</p> <p>Important: Each executed table instance must include exactly one <code>IndexBuilder</code> file, and this file must be named according to the pattern: <code>{table_name}_index.yaml</code>.</p> <pre><code>builder_type: IndexBuilder\n\nchanged_columns: ['COLUMN_NAMES']        # Output columns\npython_function: FUNCTION_NAME           # Function to execute\ncode_module: MODULE_NAME                 # Module containing the function\n\narguments:                               # Arguments passed to the function\n    ARGUMENT_NAME_1: ARG_VALUE\n    ARGUMENT_NAME_2: &lt;&lt;TABLE.COLUMN&gt;&gt;    # Reference to another table's column\n    ARGUMENT_NAME_3: ~ARTIFACT_FOLDER~   # Special keyword for artifact folder path\nn_threads: 1                             # Number of parallel workers (default 1)\n\n# Optional flags\nis_custom: false                         # True if using a user-supplied function in code_module\nreturn_type: dataframe                   # return type as one of [row-wise, dataframe, generator]\nprimary_key: ['COLUMN_NAMES']            # DataFrame primary key\nkeep_old: false                          # Keep original rows\n\n# Optional column dtypes\ndtypes:\n    COLUMN_NAME_1: Int64\n    COLUMN_NAME_2: Float64\n    COLUMN_NAME_3: artifact_string     # Special type for artifact paths\n\n# Optional explicit table dependencies\ndependencies: ['TABLE_NAME.COLUMNS']     # e.g., ['Orders.customer_id']\n</code></pre> <p>A <code>ColumnBuilder</code> is used to add new columns or modify existing ones based on calculations or transformations. It operates on the DataFrame produced by the <code>IndexBuilder</code> (or a preceding <code>ColumnBuilder</code>).</p> <p>Important: Every <code>ColumnBuilder</code> must output a DataFrame that has the exact same number of rows as the DataFrame generated by the <code>IndexBuilder</code>. The columns it creates must correspond to those listed in its <code>changed_columns</code> field.</p> <pre><code>builder_type: ColumnBuilder\n\nchanged_columns: ['COLUMN_NAMES']        # Output columns created / overwritten\n\npython_function: FUNCTION_NAME         # e.g., build_features\ncode_module: MODULE_NAME               # e.g., my_feature_lib\n\narguments:\n    ARGUMENT_NAME_1: ARG_VALUE           # Scalars, lists, environment variables, etc.\n    ARGUMENT_NAME_2: &lt;&lt;TABLE.COLUMN&gt;&gt;    # Table reference syntax\n    ARGUMENT_NAME_3: ~ARTIFACT_FOLDER~   # Special keyword for artifact folder path\nn_threads: 1                           # Parallel workers (default 1)\n\n# Optional flags\nis_custom: false                       # Mark as user-supplied (searches in code_functions)\nreturn_type: dataframe                 # return type as one of [row-wise, dataframe, generator]\n\n# Optional column dtypes\ndtypes:\n    COLUMN_NAME_1: Int64\n    COLUMN_NAME_2: Float64\n    COLUMN_NAME_3: artifact_string     # Special type for artifact paths\n\n# Optional explicit table dependencies\ndependencies: ['TABLE_NAME.COLUMNS']     # e.g., ['Products.price']\n</code></pre>"},{"location":"api/builders/#field-reference","title":"Field Reference","text":"Field Type Applicability Description <code>builder_type</code> <code>string</code> All Specifies the type of builder. Must be exactly <code>\"IndexBuilder\"</code> or <code>\"ColumnBuilder\"</code>. <code>changed_columns</code> <code>list[string]</code> All A list of column names that are introduced or modified by this builder. <code>python_function</code> <code>string</code> All The fully qualified name of the Python function to execute (e.g., <code>my_module.my_function</code>). The function must be able to accept the declared <code>arguments</code>. <code>code_module</code> <code>string</code> All The name of the Python module file (e.g., <code>my_processing_lib.py</code>) containing the function. Must have been added to the TableVault via the API. <code>arguments</code> <code>dict</code> All A key-value mapping passed to the <code>python_function</code>. Values can be scalars, lists, table references (<code>&lt;&lt;TABLE.COLUMN&gt;&gt;</code>), or the special keyword <code>~ARTIFACT_FOLDER~</code>. <code>n_threads</code> <code>int</code> All The number of parallel worker threads to use for processing. Default: <code>1</code>. <code>is_custom</code> <code>bool</code> All Indicates the function's source. If <code>true</code>, the function is loaded from a user-supplied <code>code_module</code>. If <code>false</code>, it's loaded from TableVault\u2019s built-in functions. Default: <code>false</code>. <code>return_type</code> <code>string</code> All Expected return format from <code>python_function</code>. Must be one of <code>row-wise</code>, <code>dataframe</code>, or <code>generator</code>. Default: <code>dataframe</code>. <code>keep_old</code> <code>bool</code> <code>IndexBuilder</code> only Determines how rows from a previous instance are handled. If <code>true</code>, existing rows not generated by the current run are kept. Default: <code>false</code>. <code>primary_key</code> <code>list[string]</code> <code>IndexBuilder</code> only (Optional) A list of column names that form a unique row identifier. If omitted, the row position is used. <code>dtypes</code> <code>dict</code> All (Optional) A mapping from column names to pandas data types (e.g., <code>{\"col1\": \"Int64\"}</code>). Used for type coercion and for declaring <code>artifact_string</code> columns. <code>dependencies</code> <code>list[string]</code> All (Optional) Overrides automatic dependency detection. A list of explicit table dependencies (e.g., <code>['Orders.*']</code>). Required if dependencies are not clear from <code>arguments</code>."},{"location":"api/builders/#special-builder-keywords","title":"Special Builder Keywords","text":"<p>TableVault builders support special keywords that are dynamically replaced with context-aware values at runtime. These keywords enable access to file paths and data from other tables, making configurations more powerful and flexible.</p> Keyword Syntax Scope Description Artifact Folder <code>~ARTIFACT_FOLDER~</code> <code>arguments</code> A placeholder that resolves to the absolute path of the artifact folder for the current instance run. It is essential for any function that needs to save or load artifact files. Table Reference <code>&lt;&lt;...&gt;&gt;</code> Most string fields A dynamic reference used to fetch data from other tables or the current table instance (<code>self</code>). The expression within the <code>&lt;&lt;...&gt;&gt;</code> is resolved and its value is substituted into the field. <p>Example Usage in <code>arguments</code>:</p> <pre><code>arguments:\n  # The ~ARTIFACT_FOLDER~ keyword provides the path for saving a generated file\n  artifact_output_path: ~ARTIFACT_FOLDER~\n\n  # The &lt;&lt;...&gt;&gt; syntax fetches a specific configuration value from another table\n  source_data_id: \"&lt;&lt;config_table.source_id[region::'US']&gt;&gt;\"\n</code></pre>"},{"location":"api/builders/#creating-custom-builder-functions","title":"Creating Custom\u00a0Builder Functions","text":"<p>Every builder YAML tells TableVault how to construct or modify the instance DataFrame.\u202f The <code>return_type</code> field aligns your Python function\u2019s output with the framework\u2019s expectations:</p> <code>return_type</code> Type Use Pattern Expected Return Output What TableVault does <code>dataframe</code> (default) Create whole table in one function Function returns one <code>pd.DataFrame</code> that already includes every column in <code>changed_columns</code>. Accepts the DataFrame as\u2011is and moves on. <code>row\u2011wise</code> Compute each row independently.\u201d Function is called once per input row and returns a scalar\u00a0or tuple representing that row\u2019s new values. Writes each returned row immediately; can run with multiple threads <code>generator</code> Generate rows incrementally in one function Function yields <code>(row_idx, row_tuple)</code> pairs in any row order. Writes each yielded row immediately; skipped indices remain untouched. <p>Important Notes</p> <ol> <li>Column order &amp; count\u00a0must match <code>changed_columns</code>. One column \u2192 you may return/yield a scalar.</li> <li>All values must coerce cleanly to the dtypes you declare (e.g. <code>artifact_string</code>).</li> <li>If you write artefact files, return relative paths (<code>my_plot.png</code>), not absolute ones.</li> <li>For resuming interrupted runs, rely on the previously saved-instance (you can access it by assigning <code>&lt;&lt;self&gt;&gt;</code> as an argument). Do not look at artifact files, since they might not be saved to your dataframe.</li> <li>For <code>row-wise</code> functions that correspond to an IndexBuilder, the function is called for each row in the original copied table.</li> <li>Arguments to <code>row-wise</code> will automatically resolve the <code>index</code> key-word as the current row's index.</li> </ol>"},{"location":"api/builders/#example-builders-and-functions","title":"Example Builders and Functions","text":""},{"location":"api/builders/#custom-dataframe-function","title":"Custom <code>dataframe</code> Function","text":"<p>An <code>IndexBuilder</code> that converts a <code>list</code> to a <code>DataFrame</code></p> Python CodeExample YAML Builder <pre><code>create_data_table_from_list(vals: list) -&gt; pandas.DataFrame:\n    return pd.DataFrame({\"row_index\": vals})\n</code></pre> <pre><code>builder_type: IndexBuilder\nchanged_columns: [row_index] # only single column\nprimary_key: [row_index]\npython_function: create_data_table_from_list\ncode_module: table_generation\narguments:    \n    vals: [2, 4, 6, 8]\nis_custom: false\n</code></pre>"},{"location":"api/builders/#custom-row-wise-function","title":"Custom <code>row-wise</code> Function","text":"<p>A <code>ColumnBuilder</code> that saves an <code>fruit_image</code> file for each <code>fruit</code> key</p> Python CodeExample YAML Builder <pre><code>import shutil\n\ndef fetch_image_from_string(fruit: str, artifact_dir:str ):\n\n    file_path = f'./all_images/{fruit}.png' # pre-existing file\n    new_file_path = f'{artifact_dir}/{fruit}.png'\n\n    shutil.copy(file_path, new_file_path)\n\n    return f'{fruit}.png' # return relative path\n</code></pre> <pre><code>builder_type: ColumnBuilder\n\nchanged_columns: ['fruit_image']                        # Output columns\n\npython_function: create_data_table_from_table           # Function to execute\ncode_module: table_generation                           # Module containing the function\n\nis_custom: true                                         # Mark as user-supplied (searches in code_functions)\nreturn_type: row-wise                                       # Specifies if the function processes row by row\n\narguments:                                              # Arguments passed to the function\n    fruit: &lt;&lt;self.fruits[index]&gt;&gt; \n    artifact_dir: ~ARTIFACT_FOLDER~ \n\ndtypes:                                                 # Column Data Types \n    fruit_image: artifact_string            \n</code></pre>"},{"location":"api/builders/#custom-generator-function","title":"Custom <code>generator</code> Function","text":"<p>An <code>IndexBuilder</code> that yields a batch of <code>GritLM</code> embedding to a new row</p> <p>Why this pattern matters</p> <ul> <li>Atomic progress: Each yielded row is immediately committed. If your job dies, rerunning the builder simply skips what\u2019s already in <code>self_df</code>.</li> </ul> Python CodeExample YAML Builder <pre><code>from typing import Iterator\n    from tqdm import tqdm\n    from gritlm import GritLM\n    import pandas as pd\n    import numpy as np\n    import time\n    import os\n    import torch\n    import gc\n\n    def get_batch_embeddings(df:pd.DataFrame,\n                            self_df:pd.DataFrame,\n                            artifact_column: str,\n                            raw_instruction:str,\n                            batch_size:int,\n                            artifact_name:str,\n                            artifact_folder:str)-&gt; Iterator[tuple[int, tuple[int, str, float]]]:\n        gc.collect()\n        torch.cuda.empty_cache()\n        model = GritLM(\"GritLM/GritLM-7B\", torch_dtype=\"auto\", device_map=\"auto\", mode=\"embedding\")\n\n        for index, start_index in enumerate(tqdm(range(0, len(df), batch_size), desc=\"Batches\")):\n        start_time = time.time()\n        end_index = start_index + batch_size\n        artifact_name_ = artifact_name + f\"_{start_index}_{end_index}.npy\"\n        artifact_dir = os.path.join(artifact_folder, artifact_name_)\n        if start_index in self_df['start_index']:\n            continue\n        batch_df = df.iloc[start_index:end_index][artifact_column]\n        batch_texts = []\n        for file_path in batch_df:\n            with open(file_path, 'r') as f:\n                batch_texts.append(f.read())\n        ndarr = model.encode(batch_texts, batch_size=batch_size,\n                                instruction=raw_instruction).astype(np.float16)\n        end_time = time.time()\n        np.save(artifact_dir, ndarr)\n        yield (index, (start_index, artifact_name_, end_time - start_time))\n</code></pre> <pre><code>builder_type: IndexBuilder\n\nchanged_columns: ['start_index', 'artifact_name', 'elapsed_time']        # Output columns created / overwritten\nprimary_key: ['start_index'] \npython_function: get_batch_embeddings         # e.g., build_features\ncode_module: batch_embedding                  # e.g., my_feature_lib\n\narguments:\n    df: &lt;&lt;paper_abstract_store.artifact_name&gt;&gt;\n    self_df: &lt;&lt;self&gt;&gt;\n    artifact_column: artifact_name\n    raw_instruction: \"&lt;|embed|&gt;\\n\"\n    batch_size: 4\n    artifact_name: embeddings\n    artifact_folder: ~ARTIFACT_FOLDER~\n\nis_custom: true\nreturn_type: generator\n\ndtypes:\n    artifact_name: artifact_string\n    elapsed_time: float\n</code></pre>"},{"location":"api/code_functions/","title":"Default Code Functions API","text":"<p>There are several simple code functions included with the <code>tablevault</code> library. You can execute them by specifying the right parameters in a YAML <code>Builder</code> file.</p>"},{"location":"api/code_functions/#dataframe-creation","title":"Dataframe Creation","text":"<p>These functions are loaded with <code>module_name: table_generation</code> and <code>is_custom: false</code>. They are meant to be used with an <code>IndexBuilder</code> YAML file.</p> <p>The YAML Builder tab has the specified arguments of the builder file for the specific functions. You may have to fill out additional arguments not shown.</p>"},{"location":"api/code_functions/#create_paper_table_from_folder","title":"<code>create_paper_table_from_folder</code>","text":"Python CodeYAML Builder <pre><code>create_paper_table_from_folder(\n    folder_dir: str,\n    copies: int,\n    artifact_folder: str,\n    extension: str ='.pdf'\n) -&gt; pandas.DataFrame\n</code></pre> <pre><code>builder_type: IndexBuilder\nchanged_columns: ['file_name', 'artifact_name', 'original_path']\nprimary_key: ['file_name']\npython_function: create_paper_table_from_folder\ncode_module: table_generation\narguments:\n    folder_dir: str\n    copies: int\n    artifact_folder: ~ARTIFACT_FOLDER~\n    extension: str\nis_custom: false\n\ndtypes:\n    artifact_name: artifact_string\n</code></pre> <p>Scan a directory for <code>extension</code> files, copy each into an artifact directory, and return a table describing every copy.</p> Parameter Type Description <code>folder_dir</code> <code>str</code> Folder containing the source PDFs <code>copies</code> <code>int</code> How many copies per file (\u22651) <code>artifact_folder</code> <code>str</code> Destination directory for the copies <code>extension</code> <code>str</code> File extension to be filtered <p>The resulting <code>DataFrame</code> has three columns:</p> <ol> <li><code>file_name</code> \u2013 base filename (without extension)</li> <li><code>artifact_name</code> \u2013 copied file\u2019s name (includes suffixes when <code>copies &gt; 1</code>)</li> <li><code>original_path</code> \u2013 path to the original PDF</li> </ol>"},{"location":"api/code_functions/#create_data_table_from_table","title":"<code>create_data_table_from_table</code>","text":"Python CodeYAML Builder <pre><code>create_data_table_from_table(\n    df: pandas.DataFrame,\n    nrows: int | None = None,\n    random_sample: bool = False\n) -&gt; pandas.DataFrame\n</code></pre> <pre><code>builder_type: IndexBuilder\nchanged_columns: list\npython_function: create_data_table_from_table\ncode_module: table_generation\narguments:\n    df: pandas.DataFrame\n    nrows: int # Optional\n    random_sample: bool # Optional (need nrows)\nis_custom: false\n</code></pre> <p>Return a copy of <code>df</code>, with optional truncation or random sampling.</p> Parameter Type Default Description <code>df</code> <code>pandas.DataFrame</code> Source data <code>nrows</code> <code>int</code> <code>None</code> Row limit (leave <code>None</code> for all rows) <code>random_sample</code> <code>bool</code> <code>False</code> If <code>True</code>, randomly sample <code>nrows</code> from <code>df</code>"},{"location":"api/code_functions/#create_data_table_from_csv","title":"<code>create_data_table_from_csv</code>","text":"Python CodeYAML Builder <pre><code>create_data_table_from_csv(csv_file_path: str) -&gt; pandas.DataFrame\n</code></pre> <pre><code>builder_type: IndexBuilder\nchanged_columns: list\npython_function: create_data_table_from_csv\ncode_module: table_generation\narguments:    \n    csv_file_path: str\nis_custom: false\n</code></pre> <p>Load a CSV file into a new <code>DataFrame</code> and return a copy.</p> Parameter Type Description <code>csv_file_path</code> <code>str</code> Path to the CSV on disk"},{"location":"api/code_functions/#create_data_table_from_list","title":"<code>create_data_table_from_list</code>","text":"Python CodeYAML Builder <pre><code>create_data_table_from_list(vals: list) -&gt; pandas.DataFrame\n</code></pre> <pre><code>builder_type: IndexBuilder\nchanged_columns: [str] # only single column\npython_function: create_data_table_from_list\ncode_module: table_generation\narguments:    \n    vals: list\nis_custom: false\n</code></pre> <p>Turn an in-memory Python list into a single-column table.</p> Parameter Type Description <code>vals</code> <code>list</code> Values to place in the column"},{"location":"api/code_functions/#random-string-module","title":"Random String Module","text":""},{"location":"api/code_functions/#random_row_string","title":"<code>random_row_string</code>","text":"Python CodeYAML Builder <pre><code>random_row_string(column_names: list[str], **kwargs) -&gt; tuple[str, ...] | str\n</code></pre> <pre><code>builder_type: ColumnBuilder\nchanged_columns: [str]\npython_function: random_row_string\ncode_module: random_string\narguments:    \n    column_names: list[str] # same length as changed_columns\nis_custom: false\nreturn_type: row-wise\n</code></pre> <p>Produce a single tuple of random strings\u2014one per name in <code>column_names</code>.</p> Parameter Type Description <code>column_names</code> <code>list[str]</code> Column labels that determine tuple length <code>**kwargs</code> unused Reserved for future options <p>Returns: a length-<code>len(column_names)</code> tuple of 20-character strings or a singular string (if only one column).</p>"},{"location":"api/core_api/","title":"TableVault Python Interface API","text":"<p>The core way to interact with the TableVault repository is through <code>TableVault</code> instance. Here, you can find the full API for the Python interface.</p> <p>Read Basic Workflow for an example of how to use this API.</p>"},{"location":"api/core_api/#class-tablevault","title":"Class <code>TableVault</code>","text":"<pre><code>class TableVault()\n</code></pre> <p>Interface with a TableVault repository. Initialisation can create a new vault repository and optionally restart any active processes. Subsequent methods allow interaction with tables instances, code modules, and builder files within that vault.</p> Parameter Type Description Default <code>db_dir</code> <code>str</code> Directory path where the TableVault is stored (or should be created). \u2013 <code>author</code> <code>str</code> Name or identifier of the user/system performing the operations. \u2013 <code>description</code> <code>str</code> Description for the vault creation (used only when create is True). <code>\"\"</code> <code>create</code> <code>bool</code> If True, initialise a new vault at db_dir. <code>False</code> <code>restart</code> <code>bool</code> If True, restart any processes previously active in this vault. <code>False</code> <code>verbose</code> <code>bool</code> If True, prints detailed logs of every operation. <code>True</code>"},{"location":"api/core_api/#tablevault-data-creation-methods","title":"<code>TableVault</code> Data Creation Methods","text":""},{"location":"api/core_api/#create_table","title":"<code>create_table()</code>","text":"<p>Create a new table definition in the vault.</p> <pre><code>def create_table(\n    self,\n    table_name: str,\n    allow_multiple_artifacts: bool = False,\n    has_side_effects: bool = False,\n    description: str = \"\",\n    process_id: str = \"\",\n\n) -&gt; str:\n</code></pre> Parameter Type Description Default <code>table_name</code> <code>str</code> Name of the new table. \u2013 <code>allow_multiple_artifacts</code> <code>bool</code> True \u21d2 instance has own artifact folder; False \u21d2 one folder, one active. <code>False</code> <code>has_side_effects</code> <code>bool</code> True \u21d2 builders have side effects (e.g. API calls). <code>False</code> <code>description</code> <code>str</code> Description for the table. <code>\"\"</code> <code>process_id</code> <code>str</code> Generated process identifier. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#create_instance","title":"<code>create_instance()</code>","text":"<p>Create a new temporary instance of a table.</p> <pre><code>def create_instance(\n    self,\n    table_name: str,\n    version: str = \"base\",\n    origin_id: str = \"\",\n    origin_table: str = \"\",\n    external_edit: bool = False,\n    copy: bool = False,\n    builders: Optional[dict[str, str] | list[str]] = None,\n    process_id: str = \"\",\n    description: str = \"\",\n) -&gt; str:\n</code></pre> Parameter Type Description Default <code>table_name</code> <code>str</code> Name of the table. \u2013 <code>version</code> <code>str</code> Version of the table. <code>\"base\"</code> <code>origin_id</code> <code>str</code> If supplied, copy state from this existing instance ID. <code>\"\"</code> <code>origin_table</code> <code>str</code> Table for <code>origin_id</code>; empty \u21d2 <code>table_name</code>. <code>\"\"</code> <code>external_edit</code> <code>bool</code> True \u21d2 instance edited externally, no builders constructed. <code>False</code> <code>copy</code> <code>bool</code> False (no <code>origin_id</code>) \u21d2 use latest materialised instance as origin if it exists. <code>True</code> <code>builders</code> <code>Optional[dict[str, str] \\| list[str]]</code> List of new builder names to generate. <code>None</code> <code>description</code> <code>str</code> Description for this instance. <code>\"\"</code> <code>process_id</code> <code>str</code> Process identifier. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#create_code_module","title":"<code>create_code_module()</code>","text":"<pre><code>def create_code_module(\n    self,\n    module_name: str = \"\",\n    copy_dir: str = \"\",\n    process_id: str = \"\"\n) -&gt; str:\n</code></pre> <p>Create or copy a Python module file into TableVault.</p> Parameter Type Description Default <code>module_name</code> <code>str</code> Name for the new module. <code>\"\"</code> <code>copy_dir</code> <code>str</code> Directory or Python file to copy. <code>\"\"</code> <code>process_id</code> <code>str</code> Generated process identifier. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#create_builder_file","title":"<code>create_builder_file()</code>","text":"<p>Create or update a builder (YAML) file for a temporary table instance.</p> <p>If the builder content is not specified, a template file will be created.</p> <pre><code>def create_builder_file(\n    self,\n    table_name: str,\n    builder_name: str = \"\",\n    version: str = \"base\",\n    copy_dir: str = \"\",\n    process_id: str = \"\",\n) -&gt; str:\n</code></pre> Parameter Type Description Default <code>table_name</code> <code>str</code> Name of the table. \u2013 <code>builder_name</code> <code>str</code> Builder file name; empty \u21d2 inferred. <code>{table_name}_index</code> <code>version</code> <code>str</code> Version of the table. <code>\"base\"</code> <code>copy_dir</code> <code>str</code> Directory containing builder file(s). <code>\"\"</code> <code>process_id</code> <code>str</code> Generated process identifier. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#tablevault-instance-materialization-methods","title":"<code>TableVault</code> Instance Materialization Methods","text":""},{"location":"api/core_api/#write_instance","title":"<code>write_instance()</code>","text":"<p>Write <code>table_df</code> as a materialized instance of <code>table_name</code> and <code>version</code>.</p> <p>The table must already have a temporary instance of the same version that is open for external edits (generated by <code>create_instance()</code>).</p> <pre><code>def write_instance(\n    self,\n    table_df: pd.DataFrame,\n    table_name: str,\n    version: str = '\"base\"',\n    dependencies: Optional[list[tuple[str, str]]] = None,\n    dtypes: Optional[dict[str, str]] = None,\n    process_id: str = \"\",\n) -&gt; str:\n</code></pre> Parameter Type Description Default <code>table_df</code> <code>pd.DataFrame</code> Data to write. \u2013 <code>table_name</code> <code>str</code> Target table. \u2013 <code>version</code> <code>str</code> Target version. <code>\"base\"</code> <code>dependencies</code> <code>Optional[list[tuple[str, str]]]</code> List of <code>(table_name, instance_id)</code> dependencies. None for no deps. <code>None</code> <code>dtypes</code> <code>Optional[dict[str, str]]</code> <code>{column: pandas-dtype}</code>. None for nullable defaults. <code>None</code> <code>process_id</code> <code>str</code> Generated process identifier. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 The process ID of the executed write operation.</p>"},{"location":"api/core_api/#execute_instance","title":"<code>execute_instance()</code>","text":"<p>Executes and materialise an existing temporary table instance from builder files.</p> <pre><code>def execute_instance(\n    self,\n    table_name: str,\n    version: str = \"base\",\n    force_execute: bool = False,\n    process_id: str = \"\",\n    background: bool = False,\n) -&gt; str:\n</code></pre> Parameter Type Description Default <code>table_name</code> <code>str</code> Name of the table to materialise. \u2013 <code>version</code> <code>str</code> Version of the table. <code>\"base\"</code> <code>force_execute</code> <code>bool</code> True \u21d2 force full rebuild; False \u21d2 reuse origin if possible. <code>False</code> <code>process_id</code> <code>str</code> Generated process identifier. <code>\"\"</code> <code>background</code> <code>bool</code> True \u21d2 run materialisation in background. <code>False</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#tablevault-data-deletionmodification-methods","title":"<code>TableVault</code> Data Deletion/Modification Methods","text":""},{"location":"api/core_api/#rename_table","title":"<code>rename_table()</code>","text":"<p>Rename an existing table within the TableVault repository.</p> <pre><code>def rename_table(\n    self, new_table_name: str, table_name: str, process_id: str = \"\"\n) -&gt; str:\n</code></pre> Parameter Type Description Default <code>new_table_name</code> <code>str</code> New table name. \u2013 <code>table_name</code> <code>str</code> Current table name. \u2013 <code>process_id</code> <code>str</code> Generated process identifier. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#delete_table","title":"<code>delete_table()</code>","text":"<p>Permanently delete a table and all its instances from the repository. Only the dataframes and artifacts are removed; table metadata is retained.</p> <pre><code>def delete_table(self, table_name: str, process_id: str = \"\") -&gt; str:\n</code></pre> Parameter Type Description Default <code>table_name</code> <code>str</code> Name of the table to delete. \u2013 <code>process_id</code> <code>str</code> Generated process identifier. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#delete_instance","title":"<code>delete_instance()</code>","text":"<p><pre><code>def delete_instance(\n    self, instance_id: str, table_name: str, process_id: str = \"\"\n) -&gt; str:\n</code></pre> Delete a materialised table instance from the vault. Only the dataframe is removed and artifacts; instance metadata is retained.</p> Parameter Type Description Default <code>instance_id</code> <code>str</code> ID of the instance to delete. \u2013 <code>table_name</code> <code>str</code> Name of the table owns instance. \u2013 <code>process_id</code> <code>str</code> Generated process identifier. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#delete_code_module","title":"<code>delete_code_module()</code>","text":"<p>Delete a Python module file from the repository.</p> <pre><code>def delete_code_module(self, module_name: str, process_id: str = \"\") -&gt; str:\n</code></pre> Parameter Type Description Default <code>module_name</code> <code>str</code> Name of the module to delete. \u2013 <code>process_id</code> <code>str</code> Generated process identifier. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#delete_builder_file","title":"<code>delete_builder_file()</code>","text":"<pre><code>def delete_builder_file(\n    self,\n    builder_name: str,\n    table_name: str,\n    version: str = \"base\",\n    process_id: str = \"\",\n) -&gt; str:\n</code></pre> <p>Delete a builder file from a temporary table instance.</p> Parameter Type Description Default <code>builder_name</code> <code>str</code> Name of the builder file to delete. \u2013 <code>table_name</code> <code>str</code> Owning table name. \u2013 <code>version</code> <code>str</code> Version of the table. <code>\"base\"</code> <code>process_id</code> <code>str</code> Generated process identifier. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this operation.</p>"},{"location":"api/core_api/#tablevault-process-methods","title":"<code>TableVault</code> Process Methods","text":""},{"location":"api/core_api/#generate_process_id","title":"<code>generate_process_id()</code>","text":"<pre><code>def generate_process_id(self) -&gt; str:\n</code></pre> <p>Generate and return a unique process ID. If a process ID is supplied to an operation, that operation persists on errors and can be restarted with the same ID</p> <p>Returns \u2192 <code>str</code> \u2013 A unique process identifier.</p>"},{"location":"api/core_api/#stop_process","title":"<code>stop_process()</code>","text":"<p><pre><code>def stop_process(\n    self,\n    to_stop_process_id: str,\n    force: bool = False,\n    materialize: bool = False,\n    process_id: str = \"\",\n) -&gt; str:\n</code></pre> Stop an active process and optionally terminate it forcefully.</p> Parameter Type Description Default <code>to_stop_process_id</code> <code>str</code> ID of the process to stop. \u2013 <code>force</code> <code>bool</code> True \u21d2 forcibly stop; False \u21d2 raise if still running. <code>False</code> <code>materialize</code> <code>bool</code> True \u21d2 materialise partial instances if relevant. <code>False</code> <code>process_id</code> <code>str</code> Generated process identifier. <code>\"\"</code> <p>Returns \u2192 <code>str</code> \u2013 process ID of this stop_process call.</p>"},{"location":"api/core_api/#tablevault-data-fetching-methods","title":"<code>TableVault</code> Data Fetching Methods","text":""},{"location":"api/core_api/#get_dataframe","title":"<code>get_dataframe()</code>","text":"<pre><code>def get_dataframe(\n    self,\n    table_name: str,\n    instance_id: str = \"\",\n    version: str = \"base\",\n    active_only: bool = True,\n    successful_only: bool = False,\n    rows: Optional[int] = None,\n    full_artifact_path: bool = True,\n) -&gt; tuple[pd.DataFrame, str]:\n</code></pre> <p>Retrieve a pandas <code>DataFrame</code> for a table instance.</p> Parameter Type Description Default <code>table_name</code> <code>str</code> Name of the table. \u2013 <code>instance_id</code> <code>str</code> Specific instance ID; empty \u21d2 latest of version. <code>\"\"</code> <code>version</code> <code>str</code> Version when instance_id omitted. <code>\"base\"</code> <code>active_only</code> <code>bool</code> True \u21d2 consider only active instances. <code>True</code> <code>successful_only</code> <code>bool</code> True \u21d2 consider only successful runs. <code>False</code> <code>rows</code> <code>Optional[int]</code> Row limit (<code>None</code> = no limit). <code>None</code> <code>full_artifact_path</code> <code>bool</code> True \u21d2 prefix <code>\"artifact_string\"</code> columns with the repository path <code>True</code> <p>Returns \u2192 <code>tuple[pd.DataFrame, str]</code> \u2013 (dataframe, resolved_instance_id).</p>"},{"location":"api/core_api/#get_file_tree","title":"<code>get_file_tree()</code>","text":"<p><pre><code>def get_file_tree(\n    self,\n    instance_id: str = \"\",\n    table_name: str = \"\",\n    code_files: bool = True,\n    builder_files: bool = True,\n    metadata_files: bool = False,\n    artifact_files: bool = False,\n) -&gt; rich.tree.Tree:\n</code></pre> Retrieves a RichTree object representation of the repository.</p> Parameter Type Description Default <code>instance_id</code> <code>str</code> Retrieve partial instance tree. <code>\"\"</code> <code>table_name</code> <code>str</code> Retrieve partial table tree. <code>\"\"</code> <code>code_files</code> <code>bool</code> Include stored Python modules. <code>True</code> <code>builder_files</code> <code>bool</code> Include builder files. <code>True</code> <code>metadata_files</code> <code>bool</code> Include metadata files. <code>False</code> <code>artifact_files</code> <code>bool</code> Include artifact directory contents. <code>False</code> <p>Returns \u2192 <code>rich.tree.Tree</code> \u2013 printable file-tree representation.</p>"},{"location":"api/core_api/#get_instances","title":"<code>get_instances()</code>","text":"<pre><code>def get_instances(\n    self,\n    table_name: str,\n    version: str = \"base\",\n) -&gt; list[str]:\n</code></pre> <p>Retrieves a list of instance IDs for a specific table and version.</p> Parameter Type Description Default <code>table_name</code> <code>str</code> Name of the table. \u2013 <code>version</code> <code>str</code> Version of the table. <code>\"base\"</code> <p>Returns \u2192 <code>list[str]</code> \u2013 instance IDs for this table/version.</p>"},{"location":"api/core_api/#get_active_processes","title":"<code>get_active_processes()</code>","text":"<pre><code>def get_active_processes(self) -&gt; ActiveProcessDict:\n</code></pre> <p>Retrieves a dictionary of currently active processes in the vault. Each key is a process ID and each value is metadata about that process.</p> <p>Returns \u2192 <code>ActiveProcessDict</code> \u2013 alias <code>dict[str, Mapping[str, Any]]</code>.</p>"},{"location":"api/core_api/#get_process_completion","title":"<code>get_process_completion()</code>","text":"<pre><code>def get_process_completion(self, process_id: str) -&gt; bool:\n</code></pre> <p>Retrieves the completion status of a specific process.</p> Parameter Type Description <code>process_id</code> <code>str</code> Identifier of the process. <p>Returns \u2192 <code>bool</code> \u2013 True if the process has completed, False otherwise.</p>"},{"location":"api/core_api/#get_descriptions","title":"<code>get_descriptions()</code>","text":"<pre><code>def get_descriptions(\n    self,\n    instance_id: str = \"\",\n    table_name: str = \"\",\n) -&gt; dict:\n</code></pre> <p>Retrieves the stored description metadata.</p> Parameter Type Description Default <code>instance_id</code> <code>str</code> Instance ID to describe (empty \u21d2 DB-level or table_name level). <code>\"\"</code> <code>table_name</code> <code>str</code> Table whose description is requested (ignored if <code>instance_id</code> set). <code>\"\"</code> <p>Returns \u2192 <code>dict</code> \u2013 description dictionary for the requested entity.</p>"},{"location":"api/core_api/#get_artifact_folder","title":"<code>get_artifact_folder()</code>","text":"<pre><code>def get_artifact_folder(\n    self,\n    table_name: str,\n    instance_id: str = \"\",\n    version: str = \"base\",\n    is_temp: bool = True,\n) -&gt; str:\n</code></pre> <p>Retrieves the path to the artifact folder for a given table instance. If <code>allow_multiple_artifacts</code> is False for the table, the instance is not temporary, and the instance was successfully executed, the folder for the whole table is returned.</p> Parameter Type Description Default <code>table_name</code> <code>str</code> Name of the table. \u2013 <code>instance_id</code> <code>str</code> Table\u2011instance ID. <code>\"\"</code> <code>version</code> <code>str</code> Version string. When instance_id is omitted, fetches latest of this version. <code>\"base\"</code> <code>is_temp</code> <code>bool</code> True \u21d2 path to temporary instance; False \u21d2 last materialised instance. <code>True</code> <p>Returns \u2192 <code>str</code> \u2013 path to the requested artifact folder.</p>"},{"location":"api/core_api/#get_builders_list","title":"<code>get_builders_list()</code>","text":"<p><pre><code>def get_builders_list(\n    self,\n    table_name: str,\n    instance_id: str = '',\n    version: str = \"base\",\n    is_temp: bool = True,\n) -&gt; list[str]:\n</code></pre> Retrieve a list of builder names contained in an instance.</p> Parameter Type Description Default <code>table_name</code> <code>str</code> Target table name. \u2013 <code>instance_id</code> <code>str</code> Specific instance (empty \u21d2 latest of version). <code>''</code> <code>version</code> <code>str</code> Version used when instance_id omitted. <code>\"base\"</code> <code>is_temp</code> <code>bool</code> True \u21d2 look at temporary instance; False \u21d2 materialised. <code>True</code> <p>Returns \u2192 <code>list[str]</code> \u2013 names of builder scripts in the instance.</p>"},{"location":"api/core_api/#get_builder_str","title":"<code>get_builder_str()</code>","text":"<pre><code>def get_builder_str(\n    self,\n    table_name: str,\n    builder_name: str = \"\",\n    instance_id: str = \"\",\n    version: str = \"base\",\n    is_temp: bool = True,\n) -&gt; str:\n</code></pre> <p>Retrieve a builder file as plain text.</p> Parameter Type Description Default <code>table_name</code> <code>str</code> Table that owns the builder. \u2013 <code>builder_name</code> <code>str</code> Name of the builder file (empty \u21d2 inferred). <code>{table_name}_index</code> (converted) <code>instance_id</code> <code>str</code> Specific instance (empty \u21d2 latest of version). <code>\"\"</code> <code>version</code> <code>str</code> Version used when instance_id omitted. <code>\"base\"</code> <code>is_temp</code> <code>bool</code> True \u21d2 read from temporary instance. <code>True</code> <p>Returns \u2192 <code>str</code> \u2013 full source code of the builder.</p>"},{"location":"api/core_api/#get_code_modules_list","title":"<code>get_code_modules_list()</code>","text":"<pre><code>def get_code_modules_list(self) -&gt; list[str]:\n</code></pre> <p>Retrieves a list of module names contained in this repository.</p> <p>Returns \u2192 <code>list[str]</code> \u2013 Python module names.</p>"},{"location":"api/core_api/#get_code_module_str","title":"<code>get_code_module_str()</code>","text":"<pre><code>def get_code_module_str(self, module_name: str) -&gt; str:\n</code></pre> <p>Retrieve a code module file as plain text.</p> Parameter Type Description <code>module_name</code> <code>str</code> Module name (without \u201c.py\u201d). <p>Returns \u2192 <code>str</code> \u2013 module source code.</p>"},{"location":"api/core_api/#utility-functions","title":"Utility Functions","text":"<p>These functions help transport and delete a TableVault repository.</p>"},{"location":"api/core_api/#compress_vault","title":"<code>compress_vault()</code>","text":"<pre><code>def compress_vault(db_dir: str, preset: int = 6) -&gt; None:\n</code></pre> Parameter Type Description Default <code>db_dir</code> <code>str</code> Path to the TableVault directory to compress. \u2013 <code>preset</code> <code>int</code> LZMA compression level (1-9); higher is slower but smaller. <code>6</code> <p>Raises \u2192 <code>FileNotFoundError</code> \u2013 If db_dir does not exist or is not a directory.</p>"},{"location":"api/core_api/#decompress_vault","title":"<code>decompress_vault()</code>","text":"<pre><code>def decompress_vault(db_dir: str) -&gt; None:\n</code></pre> Parameter Type Description <code>db_dir</code> <code>str</code> Path to the TableVault directory (without <code>.tar.xz</code> extension, e.g., <code>my_vault</code> for <code>my_vault.tar.xz</code>). <p>Raises \u2192 <code>FileNotFoundError</code> \u2013 If the expected archive file (<code>{db_dir}.tar.xz</code>) is missing.</p>"},{"location":"api/core_api/#delete_vault","title":"<code>delete_vault()</code>","text":"<pre><code>def delete_vault(db_dir: str) -&gt; None:\n</code></pre> Parameter Type Description <code>db_dir</code> <code>str</code> Base directory of the TableVault to delete."},{"location":"api/core_cli_api/","title":"TableVault Command Line Interface API","text":"<p>A convenient command-line interface for TableVault operations.</p> <p>Most sub-commands require a <code>TableVault</code> instance. You can provide the <code>--db-dir</code> and <code>--author</code> global options once, and they will be reused by every command invoked.</p>"},{"location":"api/core_cli_api/#global-options","title":"Global Options","text":"<p>These options can be used before any subcommand.</p> Option Type Description <code>--db-dir</code> <code>PATH</code> Path to the TableVault directory (required by most commands). <code>--author</code> <code>TEXT</code> Author name used for audit logging. <code>-h, --help</code> Show the help message and exit. <p>Example:</p> <pre><code>tablevault --db-dir ./my_vault --author jinjin get-active-processes\n</code></pre>"},{"location":"api/core_cli_api/#data-creation-commands","title":"Data Creation Commands","text":"<p>These commands require the global <code>--db-dir</code> and <code>--author</code> options to be set.</p>"},{"location":"api/core_cli_api/#create-table","title":"<code>create-table</code>","text":"<pre><code>tablevault create-table &lt;TABLE_NAME&gt; [OPTIONS]\n</code></pre> <p>Create a new table definition in the vault.</p> <p>Argument:</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the new table. <p>Options:</p> Option Description Default <code>--multiple-artifacts</code> If set, each materialised instance gets its own artifact folder. Flag (False by default) <code>--side-effects</code> If set, builder files are assumed to have side effects (e.g., external API calls). Flag (False by default) <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#create-instance","title":"<code>create-instance</code>","text":"<pre><code>tablevault create-instance &lt;TABLE_NAME&gt; [OPTIONS]\n</code></pre> <p>Create a new temporary instance of a table.</p> <p>Argument:</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the table. <p>Options:</p> Option Type Description Default <code>--version</code> <code>TEXT</code> Version of the table. <code>\"\"</code> <code>--origin-id</code> <code>TEXT</code> If supplied, copy state from this existing instance ID. <code>\"\"</code> <code>--origin-table</code> <code>TEXT</code> Table associated with <code>origin-id</code>. Defaults to <code>table_name</code> if empty. <code>\"\"</code> <code>--external-edit</code> If set, this instance will be edited externally (no builder files constructed). Flag (False by default) <code>--copy</code> If set, copy from the latest materialised instance (if <code>origin-id</code> not provided). Flag (False by default) <code>--builder</code> <code>TEXT</code> Add builder names. Can be repeated for multiple builders. None (multiple) <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#create-code-module","title":"<code>create-code-module</code>","text":"<pre><code>tablevault create-code-module [OPTIONS]\n</code></pre> <p>Copy (or create) a code-module file or directory into the vault.</p> <p>Options:</p> Option Type Description Default <code>--module-name</code> <code>TEXT</code> Name for the new module. If empty, inferred from <code>copy-dir</code>. <code>\"\"</code> <code>--copy-dir</code> <code>PATH</code> Local directory or Python file to copy. If empty, a new file is created. <code>\"\"</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#create-builder-file","title":"<code>create-builder-file</code>","text":"<pre><code>tablevault create-builder-file &lt;TABLE_NAME&gt; [OPTIONS]\n</code></pre> <p>Add or update a builder (YAML) file for a temporary table instance.</p> <p>Argument:</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the table. <p>Options:</p> Option Type Description Default <code>--builder-name</code> <code>TEXT</code> File name of the builder. If empty, inferred from <code>table_name</code>. <code>\"\"</code> <code>--version</code> <code>TEXT</code> Version of the table. <code>base</code> <code>--copy-dir</code> <code>PATH</code> Local directory containing the builder file(s) to copy. <code>\"\"</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#instance-materialization-commands","title":"Instance Materialization Commands","text":""},{"location":"api/core_cli_api/#execute-instance","title":"<code>execute-instance</code>","text":"<pre><code>tablevault execute-instance &lt;TABLE_NAME&gt; [OPTIONS]\n</code></pre> <p>Materialise an existing temporary table instance.</p> <p>Argument:</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the table to materialise. <p>Options:</p> Option Description Default <code>--version</code> <code>TEXT</code> Version of the table. <code>base</code> <code>--force</code> Force a full rebuild; otherwise, attempts to reuse an origin instance. Flag (False by default) <code>--background</code> Run materialisation in a background process. Flag (False by default) <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#write-instance","title":"<code>write-instance</code>","text":"<pre><code>tablevault write-instance &lt;TABLE_NAME&gt; --csv &lt;CSV_PATH&gt; [OPTIONS]\n</code></pre> <p>Write data from a CSV file as a materialized instance of a table. The table must already have a temporary instance of the same version open for external edits.</p> <p>Argument:</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Target table. <p>Options:</p> Option Type Description Default <code>--csv</code> <code>PATH</code> Required. CSV file containing the dataframe (must exist). \u2013 <code>--version</code> <code>TEXT</code> Table version. <code>base</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed write operation.</p>"},{"location":"api/core_cli_api/#data-deletionmodification-commands","title":"Data Deletion/Modification Commands","text":"<p>These commands require the global <code>--db-dir</code> and <code>--author</code> options to be set.</p>"},{"location":"api/core_cli_api/#rename-table","title":"<code>rename-table</code>","text":"<pre><code>tablevault rename-table &lt;OLD_NAME&gt; &lt;NEW_NAME&gt; [OPTIONS]\n</code></pre> <p>Rename an existing table within the vault.</p> <p>Arguments:</p> Argument Type Description <code>OLD_NAME</code> <code>TEXT</code> Current name of the table. <code>NEW_NAME</code> <code>TEXT</code> New name for the table. <p>Options:</p> Option Description <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#delete-table","title":"<code>delete-table</code>","text":"<pre><code>tablevault delete-table &lt;TABLE_NAME&gt; [OPTIONS]\n</code></pre> <p>Permanently delete a table and all its instances (dataframes) from the vault. Metadata is retained.</p> <p>Argument:</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the table to delete. <p>Options:</p> Option Description <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#delete-instance","title":"<code>delete-instance</code>","text":"<pre><code>tablevault delete-instance &lt;TABLE_NAME&gt; &lt;INSTANCE_ID&gt; [OPTIONS]\n</code></pre> <p>Delete a materialised table instance (dataframe) from the vault. Instance metadata is retained.</p> <p>Arguments:</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the table that owns the instance. <code>INSTANCE_ID</code> <code>TEXT</code> ID of the instance to delete. <p>Options:</p> Option Description <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#delete-code-module","title":"<code>delete-code-module</code>","text":"<pre><code>tablevault delete-code-module &lt;MODULE_NAME&gt; [OPTIONS]\n</code></pre> <p>Delete a code-module file (<code>{MODULE_NAME}.py</code>) from the vault.</p> <p>Argument:</p> Argument Type Description <code>MODULE_NAME</code> <code>TEXT</code> Name of the module to delete. <p>Options:</p> Option Description <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#delete-builder-file","title":"<code>delete-builder-file</code>","text":"<pre><code>tablevault delete-builder-file &lt;TABLE_NAME&gt; &lt;BUILDER_NAME&gt; [OPTIONS]\n</code></pre> <p>Remove a builder file from a temporary table instance.</p> <p>Arguments:</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the table that owns the builder. <code>BUILDER_NAME</code> <code>TEXT</code> Name of the builder file to delete. <p>Options:</p> Option Type Description Default <code>--version</code> <code>TEXT</code> Version of the table. <code>base</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the executed operation.</p>"},{"location":"api/core_cli_api/#process-commands","title":"Process Commands","text":"<p>These commands require the global <code>--db-dir</code> and <code>--author</code> options to be set.</p>"},{"location":"api/core_cli_api/#generate-process-id","title":"<code>generate-process-id</code>","text":"<pre><code>tablevault generate-process-id [OPTIONS]\n</code></pre> <p>Generate and return a unique process ID. This ID can be used in other operations that accept a <code>process_id</code> for persistence and restart capabilities.</p> <p>Options:</p> Option Description <code>-h, --help</code> Show this message and exit. <p>Output: Prints a new, unique process identifier.</p>"},{"location":"api/core_cli_api/#stop-process","title":"<code>stop-process</code>","text":"<pre><code>tablevault stop-process &lt;PROCESS_ID&gt; [OPTIONS]\n</code></pre> <p>Stop an active process.</p> <p>Argument:</p> Argument Type Description <code>PROCESS_ID</code> <code>TEXT</code> ID of the process to stop. <p>Options:</p> Option Description Default <code>--force</code> Force-kill the running process. Flag (False by default) <code>--materialize</code> Materialise partial instances if possible. Flag (False by default) <code>-h, --help</code> Show this message and exit. <p>Output: Prints the process ID of the stop_process operation.</p>"},{"location":"api/core_cli_api/#data-fetching-commands","title":"Data Fetching Commands","text":"<p>These commands require the global <code>--db-dir</code> and <code>--author</code> options to be set.</p>"},{"location":"api/core_cli_api/#get-dataframe","title":"<code>get-dataframe</code>","text":"<pre><code>tablevault get-dataframe &lt;TABLE_NAME&gt; --output &lt;OUTPUT_CSV&gt; [OPTIONS]\n</code></pre> <p>Fetch a table instance and write its contents to a CSV file.</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the table. Option Type Description Default <code>--output</code> <code>PATH</code> Required. Destination CSV file path. \u2013 <code>--instance-id</code> <code>TEXT</code> Specific instance ID (empty \u21d2 latest of <code>version</code>). <code>\"\"</code> <code>--version</code> <code>TEXT</code> Table version (used if <code>instance-id</code> omitted). <code>base</code> <code>--rows</code> <code>INT</code> Limit rows fetched (<code>None</code> = no limit). <code>None</code> <code>--include-inactive</code> If set, also consider inactive instances. Flag (False by default) <code>--no-artifact-path</code> Skip prepending the repository path to <code>\"artifact_string\"</code> columns. Flag (False by default) <code>-h, --help</code> Show this message and exit. <p>Output: Writes the DataFrame to <code>OUTPUT_CSV</code> and prints a JSON blob containing the resolved <code>instance_id</code>, final row count, and the CSV path.</p>"},{"location":"api/core_cli_api/#get-process-completion","title":"<code>get-process-completion</code>","text":"<pre><code>tablevault get-process-completion &lt;PROCESS_ID&gt;\n</code></pre> <p>Check if a process has completed.</p> Argument Type Description <code>PROCESS_ID</code> <code>TEXT</code> The identifier of the process to check. <p>Output: Prints <code>True</code> or <code>False</code>.</p>"},{"location":"api/core_cli_api/#get-active-processes","title":"<code>get-active-processes</code>","text":"<pre><code>tablevault get-active-processes\n</code></pre> <p>List all currently active processes in the vault.</p> <p>Output: Prints a JSON dictionary of active processes.</p>"},{"location":"api/core_cli_api/#get-instances","title":"<code>get-instances</code>","text":"<pre><code>tablevault get-instances &lt;TABLE_NAME&gt; [OPTIONS]\n</code></pre> <p>List instance IDs for a specific table and version.</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the table. Option Type Description Default <code>--version</code> <code>TEXT</code> Version of the table. <code>base</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints a JSON list of instance IDs.</p>"},{"location":"api/core_cli_api/#get-descriptions","title":"<code>get-descriptions</code>","text":"<pre><code>tablevault get-descriptions [OPTIONS]\n</code></pre> <p>Fetch description metadata for the whole database, a single table, or a specific instance.</p> Option Type Description Default <code>--table-name</code> <code>TEXT</code> Target table (omit for DB-level). <code>\"\"</code> <code>--instance-id</code> <code>TEXT</code> Specific instance (overrides table-only). <code>\"\"</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints a JSON dictionary with the requested description(s).</p>"},{"location":"api/core_cli_api/#get-artifact-folder","title":"<code>get-artifact-folder</code>","text":"<pre><code>tablevault get-artifact-folder &lt;TABLE_NAME&gt; [OPTIONS]\n</code></pre> <p>Get the path to an instance's artifact folder.</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the table. Option Type Description Default <code>--instance-id</code> <code>TEXT</code> Specific instance ID (latest if omitted). <code>\"\"</code> <code>--version</code> <code>TEXT</code> Table version. <code>base</code> <code>--temp / --materialised</code> Path to temporary (<code>--temp</code>) or materialised (<code>--materialised</code>) folder. <code>--temp</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints the path to the artifact folder.</p>"},{"location":"api/core_cli_api/#get-file-tree","title":"<code>get-file-tree</code>","text":"<pre><code>tablevault get-file-tree [OPTIONS]\n</code></pre> <p>Render a human-readable tree (text) of files stored in the vault.</p> Option Type Description Default <code>--table-name</code> <code>TEXT</code> Limit tree to a given table (optional). <code>\"\"</code> <code>--instance-id</code> <code>TEXT</code> Inspect a specific instance (else latest). <code>\"\"</code> <code>--code-files / --no-code-files</code> Include code modules. <code>--code-files</code> <code>--builder-files / --no-builder-files</code> Include builder scripts. <code>--builder-files</code> <code>--metadata-files / --no-metadata-files</code> Include JSON/YAML metadata. <code>--no-metadata-files</code> <code>--artifact-files / --no-artifact-files</code> Include artifact directory contents. <code>--no-artifact-files</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints the file-tree string.</p>"},{"location":"api/core_cli_api/#get-modules-list","title":"<code>get-modules-list</code>","text":"<pre><code>tablevault get-modules-list\n</code></pre> <p>List Python code modules stored in the repository.</p> Option Description <code>-h, --help</code> Show this message and exit. <p>Output: Prints a JSON list of module names.</p>"},{"location":"api/core_cli_api/#get-builders-list","title":"<code>get-builders-list</code>","text":"<pre><code>tablevault get-builders-list &lt;TABLE_NAME&gt; [OPTIONS]\n</code></pre> <p>Return the builder script names contained in a table instance.</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Name of the table. Option Type Description Default <code>--instance-id</code> <code>TEXT</code> Specific instance (empty \u21d2 latest). <code>\"\"</code> <code>--version</code> <code>TEXT</code> Version used if <code>instance-id</code> omitted. <code>base</code> <code>--temp / --materialised</code> Inspect a temporary (<code>--temp</code>) or final (<code>--materialised</code>) copy. <code>--temp</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints a JSON list of builder filenames.</p>"},{"location":"api/core_cli_api/#get-builder-str","title":"<code>get-builder-str</code>","text":"<pre><code>tablevault get-builder-str &lt;TABLE_NAME&gt; [OPTIONS]\n</code></pre> <p>Print the source of a stored builder script.</p> Argument Type Description <code>TABLE_NAME</code> <code>TEXT</code> Table containing the builder. Option Type Description Default <code>--builder-name</code> <code>TEXT</code> Name of the builder file (empty \u21d2 inferred). <code>{table_name}_index</code> <code>--instance-id</code> <code>TEXT</code> Specific instance (empty \u21d2 latest). <code>\"\"</code> <code>--version</code> <code>TEXT</code> Version used if <code>instance-id</code> omitted. <code>base</code> <code>--temp / --materialised</code> Read from temporary (<code>--temp</code>) or materialised (<code>--materialised</code>). <code>--temp</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints the full builder source code.</p>"},{"location":"api/core_cli_api/#get-code-module-str","title":"<code>get-code-module-str</code>","text":"<pre><code>tablevault get-code-module-str &lt;MODULE_NAME&gt;\n</code></pre> <p>Print the source of an arbitrary code module stored in the vault.</p> Argument Type Description <code>MODULE_NAME</code> <code>TEXT</code> Module name (without <code>.py</code>). Option Description <code>-h, --help</code> Show this message and exit. <p>Output: Prints the module\u2019s source code.</p>"},{"location":"api/core_cli_api/#utility-commands","title":"Utility Commands","text":"<p>These commands operate on vault directories but do not require an initialized <code>TableVault</code> instance.</p>"},{"location":"api/core_cli_api/#compress","title":"<code>compress</code>","text":"<pre><code>tablevault compress &lt;DB_DIR&gt; [OPTIONS]\n</code></pre> <p>Create a <code>DB_DIR.tar.xz</code> archive from the specified <code>DB_DIR</code>.</p> <p>Argument:</p> Argument Type Description <code>DB_DIR</code> <code>PATH</code> Path to the TableVault directory to compress (must exist). <p>Options:</p> Option Type Description Default <code>--preset</code> <code>INT</code> LZMA compression level (1-9). <code>6</code> <code>-h, --help</code> Show this message and exit. <p>Output: Prints a confirmation message with the name of the created archive, e.g., \"Compressed \u2192 my_vault.tar.xz\".</p>"},{"location":"api/core_cli_api/#decompress","title":"<code>decompress</code>","text":"<pre><code>tablevault decompress &lt;ARCHIVE&gt; [OPTIONS]\n</code></pre> <p>Extract a <code>*.tar.xz</code> archive into a directory named after the archive (without the <code>.tar.xz</code> extension).</p> <p>Argument:</p> Argument Type Description <code>ARCHIVE</code> <code>PATH</code> Path to the <code>*.tar.xz</code> archive file (must exist). <p>Options:</p> Option Description <code>-h, --help</code> Show this message and exit. <p>Output: Prints a confirmation message with the name of the directory where files were decompressed, e.g., \"Decompressed \u2192 my_vault/\".</p>"},{"location":"api/core_cli_api/#delete-vault","title":"<code>delete-vault</code>","text":"<pre><code>tablevault delete-vault &lt;DB_DIR&gt; [OPTIONS]\n</code></pre> <p>Irreversibly delete an entire TableVault directory. This command will ask for confirmation before proceeding.</p> <p>Argument:</p> Argument Type Description <code>DB_DIR</code> <code>PATH</code> Path to the TableVault directory to delete (must exist). <p>Options:</p> Option Description <code>--yes</code> Skip the confirmation prompt. <code>-h, --help</code> Show this message and exit. <p>Output: Prints \"Vault deleted \u2714\" upon successful deletion.</p>"},{"location":"api/table_references/","title":"<code>TableReference</code> String Guide","text":"<p><code>TableReference</code> strings provide a powerful way to dynamically fetch and use data from other table instances, or the current table instance, directly within most string-based fields of your builder YAML files. This allows for highly dynamic and data-driven configurations.</p>"},{"location":"api/table_references/#core-concept-the-wrapper","title":"Core Concept: The <code>&lt;&lt; ... &gt;&gt;</code> Wrapper","text":"<p>The fundamental syntax for a <code>TableReference</code> string is to enclose the reference string within double angle brackets: <code>&lt;&lt; ... &gt;&gt;</code>.</p> <p>The <code>&lt;&lt; ... &gt;&gt;</code> syntax can be applied to any singular string, boolean or numeric entry in your builder definition, such as values in the <code>arguments</code> block, items in the <code>changed_columns</code> list, or even the <code>python_function</code> and <code>code_module</code> names themselves. </p> <p>The primary exception is the <code>dependencies</code> field, which does not support this dynamic resolution (<code>dependencies</code> inform the system which tables are loaded and must be resolved before <code>TableReference</code> strings are parsed).</p> <p>Example of broad usage in a builder YAML:</p> <pre><code># In an IndexBuilder or ColumnBuilder\nbuilder_type: IndexBuilder\npython_function: \"&lt;&lt;config_table.builder_function_name[use_case::'main_index']&gt;&gt;\" # Dynamic function name\ncode_module: \"&lt;&lt;config_table.builder_module_name&gt;&gt;\" # Dynamic module name\n\nchanged_columns:\n  - \"&lt;&lt;config_table.primary_output_column&gt;&gt;\"       # Dynamic column name\n  - \"fixed_secondary_column\"\n  - \"&lt;&lt;self.another_dynamic_column_name_source[index]&gt;&gt;\" # Column name derived from self\n\narguments:\n  source_file_path: \"/data/raw/&lt;&lt;config_table.file_name[source_id::'source_A']&gt;&gt;.csv\"\n  lookup_value: \"&lt;&lt;lookup_table.value[key::&lt;&lt;self.current_key[index]&gt;&gt;]&gt;&gt;\"\n  static_text_with_ref: \"Report for ID: &lt;&lt;self.id[index]&gt;&gt;\"\n</code></pre> <p>If a field value is entirely a <code>TableReference</code> string (e.g., <code>python_function: \"&lt;&lt;config.func_name&gt;&gt;\"</code>), the resolved value of the reference will be used directly. If the reference is part of a larger string (e.g., in <code>arguments</code>), the resolved value will be converted to a string and substituted into place.</p>"},{"location":"api/table_references/#anatomy-of-a-tablereference-string","title":"Anatomy of a <code>TableReference</code> String","text":"<p>Inside the <code>&lt;&lt; ... &gt;&gt;</code> wrapper, a <code>TableReference</code> string follows a specific structure to identify the table, an optional instance_id, specific columns, and optional filtering conditions:</p> <pre><code>tableName(instance_id).{column1,column2,...}[condition1,condition2,...]\n</code></pre> <p>All parts (instance_id, columns, conditions) are optional.</p> <p>Components:</p> <ol> <li><code>tableName</code>: The name of the table to query.</li> <li><code>(instance_id)</code>: (Optional) Specifies a particular instance of the table.</li> <li><code>.{columns}</code> or <code>.COLUMN</code>: (Optional) Selects specific columns.</li> <li><code>[conditions]</code>: (Optional) Filters the rows of the table.</li> </ol>"},{"location":"api/table_references/#1-table-name-tablename","title":"1. Table Name (<code>tableName</code>)","text":"<ul> <li>Syntax: A string of alphanumeric characters, underscores (<code>_</code>), or hyphens (<code>-</code>).</li> <li>Special Keyword <code>self</code>: The keyword <code>self</code> refers to the current table instance being processed by the builder.</li> </ul> <p><code>self</code> Keyword</p> <p>The <code>self</code> keyword cannot be be used in the <code>dtypes</code> field of a builder. The <code>dtypes</code> keyword is used when the</p> <ul> <li>Dynamic Table Name: The table name itself can be a nested <code>TableReference</code> string.<ul> <li>Example in a field: <code>code_module: \"&lt;&lt; &lt;&lt;table_map.module_column[type::'etl']&gt;&gt; &gt;&gt;\"</code></li> <li>Reference string example: <code>&lt;&lt; &lt;&lt;another_table.config_key[type::'source']&gt;&gt;.data_column &gt;&gt;</code></li> </ul> </li> </ul>"},{"location":"api/table_references/#2-version-instance_id","title":"2. Version (<code>(instance_id)</code>)","text":"<ul> <li>Syntax: Instance in parentheses, e.g., <code>(base_1748113624_d049944b-8548-46d2-a247-bbf3769fbadc)</code>.</li> <li>Optional: If omitted, TableVault will typically use the latest available instance of the table based on its internal logic and cache.</li> <li>Dynamic Version: The version string can be a nested <code>TableReference</code>.<ul> <li>Example reference string: <code>my_table(&lt;&lt;version_control_table.active_version[table_name::'my_table']&gt;&gt;)</code></li> </ul> </li> </ul>"},{"location":"api/table_references/#3-columns-columns-or-column","title":"3. Columns (<code>.{columns}</code> or <code>.COLUMN</code>)","text":"<ul> <li>Syntax:<ul> <li>Single Column: Preceded by a dot (<code>.</code>), e.g., <code>.user_id</code>.</li> <li>Multiple Columns: Preceded by a dot (<code>.</code>) and enclosed in curly braces <code>{}</code>, with column names separated by commas, e.g., <code>.{name,email,age}</code>.</li> </ul> </li> <li>Optional:<ul> <li>If omitted, and conditions are present, all columns are available for filtering, and the selected columns depend on the output simplification (see below).</li> <li>If omitted, and no conditions are present, the entire DataFrame (or its simplified form) is returned.</li> </ul> </li> <li>Dynamic Column Names: Column names within the list (or the single column name) can be nested <code>TableReferences</code>. This is highly relevant for fields like <code>changed_columns</code> or <code>primary_key</code>.<ul> <li>Example in <code>changed_columns</code>: <code>changed_columns: [\"id\", \"&lt;&lt;config_table.main_data_field_name&gt;&gt;\"]</code></li> <li>Example reference string for a column name: <code>my_table.&lt;&lt;config.target_column&gt;&gt;</code></li> <li>Example reference string with multiple dynamic columns: <code>my_table.{id,&lt;&lt;audit_table.tracked_field[user::'admin']&gt;&gt;,status}</code></li> </ul> </li> <li>Special Case: <code>self.index</code>:     If you use <code>&lt;&lt;self.index&gt;&gt;</code> (assuming <code>index</code> is the name of the designated index column/concept in your TableVault constants), this specifically resolves to the current row's index value during row-wise operations or when an <code>index</code> context is available.</li> </ul>"},{"location":"api/table_references/#4-conditions-conditions","title":"4. Conditions (<code>[conditions]</code>)","text":"<ul> <li>Syntax: Enclosed in square brackets <code>[...]</code>. Multiple conditions are separated by commas <code>,</code>.</li> <li>Optional: If omitted, all rows (of the selected version and columns) are considered.</li> <li>Each condition specifies a column to filter on and the criteria.</li> </ul> <p>Condition Types:</p> <ol> <li> <p>Equality (<code>columnName::value</code>):</p> <ul> <li>Filters rows where <code>columnName</code> equals <code>value</code>.</li> <li>Example reference string: <code>orders.product_id[customer_id::'cust123',status::'shipped']</code></li> <li>The <code>value</code> is automatically quoted for string comparisons if not already quoted (e.g., <code>status::shipped</code> becomes <code>status == 'shipped'</code>). Numerical values are used directly.</li> <li><code>value</code> can be a nested a <code>TableReference</code> string: <code>orders.items[user_id::&lt;&lt;user_table.id[username::'jdoe']&gt;&gt;]</code></li> </ul> </li> <li> <p>Range (<code>columnName::start_value:end_value</code>):</p> <ul> <li>Filters rows where <code>columnName</code> is greater than or equal to <code>start_value</code> AND less than <code>end_value</code>.</li> <li>Example reference string: <code>events.timestamp[timestamp::'2023-01-01T00:00:00':'2023-01-01T23:59:59']</code></li> <li><code>start_value</code> and <code>end_value</code> can be literals or nested <code>TableReference</code> strings. Values are formatted appropriately for comparison based on the column's data type.</li> </ul> </li> <li> <p>Implicit Index/Contextual Value (<code>columnName</code>):</p> <ul> <li>Filters rows where <code>columnName</code> equals a contextually provided <code>index</code> value (the index of the row currently being processed by the builder).</li> <li>Example: If processing row <code>101</code> of <code>self</code>, then the reference <code>&lt;&lt;other_table.data_column[join_key_in_other_table]&gt;&gt;</code> (within an argument) would attempt to find rows in <code>other_table</code> where <code>join_key_in_other_table == 101</code>.</li> <li>This is particularly useful for lookups related to the current item in <code>self</code>.</li> <li>If <code>self.some_column[key_column]</code> is used, and <code>index</code> is defined, it implies <code>self.some_column</code> where <code>key_column == index</code>.</li> </ul> </li> </ol> <p><code>index</code> Condition</p> <p>The <code>index</code> keyword can only be used in the <code>arguments</code> key of a row-wise function (when <code>row-wise</code> is set to <code>true</code>).</p> <ul> <li>Dynamic Keys and Values: All parts of a condition (the column name, the value, start/end values) can be nested <code>TableReference</code> strings.<ul> <li>Example reference string: <code>my_table[&lt;&lt;config.filter_column&gt;&gt;::&lt;&lt;config.filter_value&gt;&gt;]</code></li> </ul> </li> </ul>"},{"location":"api/table_references/#nested-references","title":"Nested References","text":"<p>As shown in examples above, any component of a <code>TableReference</code> string \u2014the table name, version string, column names, condition keys, or condition values\u2014can itself be another <code>TableReference</code> stringenclosed in <code>&lt;&lt; ... &gt;&gt;</code>. TableVault will resolve the innermost references first and use their results to construct the outer reference before resolving it.</p> <p>Complex Example (from code, used in an argument): <code>&lt;&lt;stories.artifact_name[paper_name::&lt;&lt;self.paper_name[index]&gt;&gt;]&gt;&gt;</code></p> <ol> <li> <p><code>&lt;&lt;self.paper_name[index]&gt;&gt;</code>: Resolves first. It fetches the <code>paper_name</code> from the current row (<code>index</code>) of the <code>self</code> table.</p> </li> <li> <p>Let's say the above yields <code>'my_research_paper'</code>.</p> </li> <li> <p>The outer reference becomes: <code>&lt;&lt;stories.artifact_name[paper_name::'my_research_paper']&gt;&gt;</code>.</p> </li> <li> <p>This then fetches <code>artifact_name</code> from the <code>stories</code> table where <code>paper_name</code> is <code>'my_research_paper'</code>.</p> </li> </ol>"},{"location":"api/table_references/#resolution-and-data-retrieval","title":"Resolution and Data Retrieval","text":"<ul> <li>When a builder is executed, TableVault parses these reference strings from the relevant YAML fields.</li> <li>It uses an internal cache of DataFrames (for already loaded tables and versions) to retrieve data efficiently.</li> <li>For references involving <code>self</code> or implicit index conditions, the context of the current row being processed (often an integer <code>index</code>) is crucial for resolving the correct data.</li> <li>The recursive parsing handles references within lists, dictionaries (values, and potentially keys if supported by the structure and parser), and other nested structures in the YAML, as long as they ultimately resolve to strings or collections of strings where references are found.</li> </ul>"},{"location":"api/table_references/#examples-of-reference-strings","title":"Examples of Reference Strings","text":"<p>These examples illustrate the reference string syntax itself. These strings would be placed inside <code>&lt;&lt; &gt;&gt;</code> within a suitable YAML field.</p> <ol> <li> <p>Fetch a single column from another table: <code>my_data_table.user_email</code> (When used as <code>\"&lt;&lt;my_data_table.user_email&gt;&gt;\"</code>, result: A list of all user emails from <code>my_data_table</code>, or a simplified form)</p> </li> <li> <p>Get a specific value using a filter: <code>users_table.full_name[user_id::'user-007']</code> (When used as <code>\"&lt;&lt;users_table.full_name[user_id::'user-007']&gt;&gt;\"</code>, result: The <code>full_name</code> for <code>user_id</code> 'user-007', likely a single string)</p> </li> <li> <p>Get a value from <code>self</code> based on the current row's context (implicit index): <code>self.status[id_column_of_self]</code> (When used as <code>\"&lt;&lt;self.status[id_column_of_self]&gt;&gt;\"</code>, and the current processing index is, e.g., <code>101</code>, this effectively becomes <code>self.status</code> where <code>id_column_of_self == 101</code>)</p> </li> <li> <p>Reference with a specific version: <code>app_settings(base_1748275064_5782ef5b-4023-4618-a419-cf921c365c64).timeout_ms</code></p> </li> <li> <p>Using a range condition: <code>transactions.amount[transaction_date::'2024-01-01':'2024-01-31']</code></p> </li> <li> <p>Nested reference for dynamic filtering: <code>preferences.setting_value[user_id::&lt;&lt;self.user_identifier[index]&gt;&gt;, setting_key::'theme']</code></p> </li> </ol>"},{"location":"api/table_references/#error-handling","title":"Error Handling","text":"<p>If a <code>TableReference</code> string is malformed (e.g., unbalanced brackets, illegal characters) or if a reference cannot be resolved at runtime (e.g., table not found, column missing, nested reference fails), a <code>TableReferenceError</code> will typically be raised, halting the builder process. Ensure your references are correct and the data they point to exists.</p>"},{"location":"auxillary/about/","title":"About TableVault","text":""},{"location":"auxillary/about/#citations-and-papers","title":"Citations and Papers","text":"<p>Feel free to read our paper to get more details about the project:</p> <ul> <li>TableVault: Managing Dynamic Data Collections for LLM-Augmented Workflows. Jinjin Zhao and Sanjay Krishnan.</li> </ul> <p>You can cite the paper with:</p> <pre><code># t.b.d.\n</code></pre>"},{"location":"auxillary/about/#contact","title":"Contact","text":"<p>You can reach out through email: j2zhao@uchicago.edu.</p>"},{"location":"auxillary/about/#potential-future-extensions","title":"(Potential) Future Extensions","text":"<ul> <li> <p>More Backend Options: We currently use pandas and CSV files as the backend for TableVault. While there are significant performance drawbacks to both frameworks, they were chosen for their popularity. Alternative backends are definitely under consideration to enable more user freedom in how dataframes are stored, loaded, and queried.</p> </li> <li> <p>SQL Support (Very Likely): TableReferences were designed to be easily understandable for users familiar with Pandas/Python indexing. However, there's a good argument that SQL queries can also be used for the same purpose. In practice, this shouldn't (hopefully) be too difficult to implement and will probably be added in the future.</p> </li> <li> <p>Better Query Support: Support for queries is still relatively limited. As we explore applications of TableVault, it will become clearer how data in TableVault should be accessed.</p> </li> </ul>"},{"location":"core_concepts/execution/","title":"Builders, Python Functions, <code>TableReference</code> Strings, and Artifacts","text":"<p>For simple examples of how to use builders to generate an instance, check out Basic Workflow and Worflow with Artifacts.</p>"},{"location":"core_concepts/execution/#creating-instances-from-builders","title":"Creating Instances From Builders","text":"<p>TableVault instances are typically constructed and modified through a series of orchestrated steps. At the heart of this process are builders files, which are configuration files that define the scope of data transformations, and Python files, which define the data transformation itself. This construction uses <code>TableReference</code> strings to link fetch data from previous instances, and can optionally generate TableVault artifacts to store arbitrary files. </p> <p>Execution of instances typically are initialized with the <code>execute_instance()</code> function. Alternatively, to bypass the process, you can also externally generate your dataframe and artifacts, and add them into your TableVault repository using the <code>write_instance()</code> function. This is not typically recommended since execution and data lineage information is lost. </p>"},{"location":"core_concepts/execution/#builders","title":"Builders","text":"<p>Every table instance executed by TableVault possesses its own set of builder files. You can add builders to a temporary instance by copying them from a previous origin instance, specifying builder names during <code>create_instance()</code>, or using the <code>create_builder_file()</code> function. Each builder uniquely modifies a set of specified columns in the resulting dataframe. This is specified by the mandatory <code>changed_columns</code> field. For a full list of builder fields, please read the Builders Guide.</p> <p>Builders do not contain the data transformation logic themselves. Instead, they point to the Python functions that perform the actual work. This connection is established through the <code>python_function</code> and <code>code_module</code> fields in the builder's YAML file.</p> <ul> <li><code>code_module</code>: This field specifies the Python file containing the transformation function. This module must be added to TableVault using <code>create_code_module()</code>.</li> <li><code>python_function</code>: This is the name of the function within the <code>code_module</code> that will be executed. This function receives the arguments defined in the <code>arguments</code> section of the builder file.</li> </ul> <p>When executing an instance (with the <code>execute_instance()</code> function), TableVault first runs the <code>IndexBuilder</code> configuration to generate the initial set of rows. Subsequent <code>ColumnBuilders</code> builders are executed based on internal column dependencies. These dependencies are automatically extracted by parsing for <code>&lt;&lt;self.COLUMN_NAME&gt;&gt;</code> Table Reference values in each file. Note that cyclic dependencies will result in an error.</p> <p>Data Caching</p> <p>If the executing instance is copied from a previous instance, TableVault reuses data unless disabled by setting <code>force_execute</code> to be <code>True</code> in <code>execute_instance()</code>. If the builder file, code file, and table dependencies have not changed from the previous instance, the rows with the same primary key columns are directly duplicated from the origin instance.</p> <p>Physical Location</p> <p></p> <p>TableVault Builders Location</p>"},{"location":"core_concepts/execution/#custom-python-functions","title":"Custom Python Functions","text":"<p>Python functions execute the logic defined by builders. They reside in the repository-level <code>code_function/</code> directory. You can create or copy Python files into this folder using <code>create_code_module()</code>. Once created, they are editable directly.</p> <p>Functions must adhere to specific contracts:</p> <ul> <li><code>dataframe</code>: Return a complete <code>pd.DataFrame</code>.</li> <li><code>row-wise</code>: Return a single row.</li> <li><code>generator</code>: Yield rows for streaming into DataFrames.</li> </ul> <p>For successful execution, all required input arguments for the Python function must be defined in the builder file.</p> <p>For a list of default Python functions that come with TableVault, please visit the Default Code Function API.</p> <p>Physical Location</p> <p></p> <p>TableVault Code Folder Location</p>"},{"location":"core_concepts/execution/#tablereference-strings","title":"<code>TableReference</code> strings","text":"<p><code>TableReference</code> strings enable you to dynamically pull data from any active instance to configure your builder files.</p> <p>Instead of hard-coding values in the file, you can use a special <code>&lt;&lt; ... &gt;&gt;</code> syntax to fetch information from tables, making your configurations more flexible and automated. For example, you can use a reference to:</p> <ul> <li>Pull a specific setting from a central configuration table.</li> <li>Get a list of column names to be generated.</li> <li>Look up a value from another table based the index of the current row being processed.</li> </ul> <p>You can specify which table to query, filter for specific rows, and select the exact columns you need. References can even be nested to handle complex, multi-step lookups. The system automatically retrieves the data\u2014whether it's a single value, a number, or a list\u2014and inserts it into your configuration where the reference was placed.</p> <p>For the full document on <code>TableReference</code> strings, read the TableReference Guide.</p> <p>Examples</p> <p>Here is a simple example showing a <code>TableReference</code> string within a builder's arguments:</p> <pre><code># Example: Using a TableReference to get a configuration value\narguments:\n  model_version: '&lt;&lt;config_table.value[setting_name::'prod_model_version']&gt;&gt;'\n  api_key: '&lt;&lt;secrets_table.key[service::'external_api']&gt;&gt;'\n</code></pre>"},{"location":"core_concepts/execution/#artifacts","title":"Artifacts","text":"<p>In TableVault, an artifact is any non-dataframe file, such as an image, log, or serialized model, that is linked to a specific value in a table dataframe. This creates an organized and powerful connection between structured data and related unstructured files.</p> <p>Artifacts are linked to specific instance or table folders. Temporary instances always contain its own isolated artifact folder; this folder is moved to a materalized location after the library validates that each artifact storied has a reference in its corresponding dataframe.</p> <p>Check out Worflow with Artifacts to see an exmple of artifacts being linked in TableVault. </p> <p>Use Cases</p> <p>Artifacts support diverse applications:</p> <ul> <li>Machine Learning: Store model checkpoints, performance charts, logs.</li> <li>Data Analysis: Link invoices or detailed CSVs to summarized data.</li> <li>Computer Vision: Associate metadata rows with images/videos.</li> <li>General Record-Keeping: Store manuals, warranties, marketing documents alongside product data.</li> </ul> <p>Retrieval is straightforward via the TableVault API: retrieving the base dataframe with <code>get_dataframe()</code> automatically generates the path to each stored artifact (relative to the base TableVault directory).</p> <p>Physical Location</p> <p></p> <p>TableVault Artifact Folder Location</p>"},{"location":"core_concepts/operations/","title":"Operations","text":"<p>TableVault manages every write operation through a multi-step process designed for safety and recoverability. This process involves distinct setup, execution, and takedown phases to ensure the repository remains in a consistent state, even if an operation is interrupted.</p> <p>For simple examples of how to use operations, check out Basic Workflow and Worflow with Artifacts.</p> <p>For a detailed list of available operations, please read the Core API.</p>"},{"location":"core_concepts/operations/#process-ids-pauses-and-restarts","title":"Process IDs, Pauses, and Restarts","text":"<p>Operations can include an optional <code>process_id</code>:</p> <ul> <li>Without a provided <code>process_id</code>: Unexpected interruptions cause a safe revert to the pre-operation state.</li> <li>With a provided <code>process_id</code>: Interruptions pause the operation, maintaining locks. Users can restart exactly where paused by reusing the same <code>process_id</code> or setting <code>restart</code> to <code>True</code>.</li> </ul> <p>Explicitly stopping active processes uses <code>stop_process()</code>. Logs of operations reside in <code>TABLEVAULT_NAME/metadata/logs.txt</code>.</p> <p>For detailed use scenarios of <code>process_id</code> and basic error handling procedures, check ou Handling Execution Errors.</p>"},{"location":"core_concepts/operations/#the-core-transactional-steps","title":"The Core Transactional Steps","text":"<p>Each write operation follows a series of universal, transactional steps:</p> <ol> <li> <p>Process Initialization: TableVault generates a unique internal <code>process_id</code> if one is not provided.</p> </li> <li> <p>Setup Phase: An operation-specific setup function prepares for the main task. It is responsible for validation (e.g., checking for illegal arguments), acquiring exclusive and shared locks on resources, creating a temporary backup of data to be modified, and preparing arguments for the execution phase.</p> </li> <li> <p>Execution Phase: If setup is successful, the main operation function is called. The system supports background execution for <code>execute_instance()</code> calls by spawning a new Python process.</p> </li> <li> <p>Takedown Phase: After execution, a takedown function cleans up the process. On success, it removes the temporary backup and releases locks. On failure, it uses the backup to restore the original data, effectively rolling back any changes before releasing locks.</p> </li> <li> <p>Logging: The operation's status is logged to persistent storage throughout the entire process to ensure system resiliency.</p> </li> </ol> <p>For a list of available operations, please read our core API.</p>"},{"location":"core_concepts/operations/#example-the-delete-operation","title":"Example: The Delete Operation","text":"<p>The <code>setup_delete_instance()</code> and <code>takedown_delete_instance()</code> internal functions provide a concrete example of this process.</p> <ul> <li>Setup (<code>setup_delete_instance()</code>): Validates that the table and instance exist, acquires an exclusive lock, copies the instance to a temporary directory, and logs the <code>table_name</code> and <code>instance_id</code> for cleanup.</li> <li>Takedown (<code>takedown_delete_instance()</code>): If the main logic failed, it restores the instance from the temporary directory. If it succeeded, it deletes the temporary backup. Finally, it releases all locks.</li> </ul> <p>TableVault ensures operations are transactional, leaving repositories either fully updated or reverted safely.</p>"},{"location":"core_concepts/structure/","title":"Repository Structure","text":"<p>The TableVault repository stores and organizes all data and code transparently within your local file system. This design allows you to view files directly and simply transfer in-progress workflows across devices.</p>"},{"location":"core_concepts/structure/#tablevault-repository","title":"TableVault Repository","text":"<p>The following diagram illustrates the internal storage structure of a TableVault repository:</p> <p></p> <p>TableVault File Structure</p> <p>Direct File Edits</p> <p>While the files are transparently exposed, directly editing files is generally discouraged - with two exceptions: Builder (YAML) and Python code files may be modified using an external editor. To help prevent accidental modifications on Unix systems, TableVault sets certain files to read-only. While this does not stop intentional changes, it serves as a safeguard against common mistakes.</p>"},{"location":"core_concepts/structure/#tablevault-instance","title":"TableVault Instance","text":"<p>A TableVault instance represents a dataframe with its associated metadata and optional artifacts. All files relevant to an instance are stored in a dedicated instance folder. There are two types of instances:</p> <ul> <li>Temporary Instance: An instance that has not yet been executed and cannot be queried. It is created with <code>create_instance()</code> and contains metadata, a description, and builder files. The <code>external_edit</code> parameter specifies whether the instance will be built internally by TableVault (<code>False</code>) or populated by an external process (<code>True</code>).</li> <li>Materialized Instance: An instance that has been executed and is indexed by TableVault. Its dataframe is read-only. If the instance is active, its data and metadata can be fetched via the API. The code functions and builder files used at execution are recorded. Materialized instances are versioned by a timestamp and an optional <code>version</code> string.</li> </ul> <p>A free-form description can be added via the <code>create_instance()</code> function.</p>"},{"location":"core_concepts/structure/#table-folder","title":"Table Folder","text":"<p>In TableVault, a \"table\" is a semantic collection of instances that can be referenced by the same name. All instances of a table are stored together in the same folder. In many API functions, the latest instance of a table can be retrieved using only the <code>table_name</code> reference.</p> <p>Instances under the same table can share additional properties set during table initialization:</p> <ul> <li>If <code>allow_multiple_artifacts</code> is set to <code>False</code>, only the latest instance can be queried, and only its artifacts are stored.</li> <li>If <code>has_side_effects</code> is set to <code>True</code>, all other instances of the table become un-queryable the moment one instance begins execution. This is useful if an operation invalidates previous versions.</li> </ul> <p>Examples of tables include a collection of instances testing different model prompts, a repository of scientific papers, or evolving versions of an embedding model. A free-form description can be added via the <code>create_table()</code> function.</p>"},{"location":"core_concepts/structure/#metadata","title":"Metadata","text":"<p>A TableVault repository stores various metadata files. A detailed list of these files and their functions can be found in Advanced.</p>"},{"location":"examples/api_call_example/","title":"Short Stories Q&amp;A with OpenAI","text":"<p>Check out: OpenAI Short Stories Colab Notebook</p>"},{"location":"examples/local_embeddings_example/","title":"GritLM Embeddings from Scientific Abstracts","text":"<p>Check out: GritLM Embeddings Colab Notebook</p>"},{"location":"workflows/agents/","title":"Workflow with Agents [Future]","text":"<p>You can create and execute a custom Python function that creates a new instance of the <code>TableVault</code> object. This object can interact safely with the repository while the original function is running. Agentic behaviors safely monitored with these dynamic pipelines.</p> <p>More tuturials on this to come.</p>"},{"location":"workflows/errors/","title":"Handling Execution Errors","text":"<p>This document explains the typical procedure when TableVault encounters execution errors. To understands processes in TableVault in general, please visit Core Concepts: Operations.</p>"},{"location":"workflows/errors/#1-external-errors-without-a-user-provided-process_id-and-internal-tablevault-errors","title":"1. External Errors Without a User-Provided <code>process_id</code> and Internal TableVault Errors","text":"<p>If an operation encounters an unexpected external error, it is safely reverted. The system state will be as if the operation never started.</p> <p>Internal TableVault-generated errors, regardless of <code>process_id</code> status, will always cause the operation to revert. These errors typically indicate that some user input is invalid and needs to be fixed.</p> <p>Executing Instances</p> <p>Partially executed dataframes are not reverted for debugging purposes. However, if you rerun the <code>execute_instance()</code> operation, the full dataframe is rebuilt. After an error, in this case, you can still directly edit the builder and Python module files as if the instance had not executed.</p>"},{"location":"workflows/errors/#example-external-error-code","title":"Example External Error Code","text":"1. Initial Code2. Example Error3. Rerun Code <pre><code>tablevault.execute_instance(table_name='openai_responses')\n</code></pre> <pre><code>openai.error.APIConnectionError: HTTPSConnectionPool(\n    host='api.openai.com',\n    port=443\n): Max retries exceeded with url: /v1/chat/completions\n(Caused by NewConnectionError('Temporary failure in name resolution'))\n</code></pre> <pre><code># re-execute the command\ntablevault.execute_instance(table_name='openai_responses')\n# restarts from the beginning\n</code></pre>"},{"location":"workflows/errors/#example-tablevault-error-code","title":"Example TableVault Error Code","text":"1. Initial Code2. Example Error3. Rerun Code <pre><code>tablevault.make_table(table_name='artifacts')\n</code></pre> <pre><code>tv_errors.TVArgumentError: Forbidden Table Name: artifacts\n</code></pre> <pre><code>tablevault.make_table(table_name='short_stories_store')\n</code></pre>"},{"location":"workflows/errors/#2-external-errors-with-process_id-and-system-interrupts","title":"2. External Errors with <code>process_id</code> and System Interrupts","text":"<p>With a user-provided <code>process_id</code>, an error only pauses the operation. It maintains its system locks, preventing other operations from accessing the same resources. This is especially useful for long-running <code>execute_instance()</code> operations that might be stopped.</p> <p>This is also true if the program is externally interrupted (e.g., by killing a Jupyter Notebook cell).</p> <p>Note that the operation restarts from its last checkpoint, and its input arguments cannot be changed.</p>"},{"location":"workflows/errors/#example-code","title":"Example Code","text":"1. Initial Code2. Example Error3. Rerun Code <pre><code># generate process_id\nprocess_id = tablevault.generate_process_id()\n# execute process\ntablevault.execute_instance(table_name='openai_responses', process_id=process_id)\n</code></pre> <pre><code>openai.error.APIConnectionError: HTTPSConnectionPool(\n    host='api.openai.com',\n    port=443\n): Max retries exceeded with url: /v1/chat/completions\n(Caused by NewConnectionError('Temporary failure in name resolution'))\n</code></pre> <pre><code># re-execute the command with the SAME process_id\ntablevault.execute_instance(table_name='openai_responses', process_id=process_id)\n# restarts from checkpoint\n</code></pre>"},{"location":"workflows/errors/#restart-process","title":"Restart Process","text":"<p>You can restart the exact same operation by rerunning the function call with the same <code>process_id</code> or by setting <code>restart</code> to <code>True</code> in a new TableVault object. In the latter case, we assume a system crash, and all currently active processes are restarted.</p>"},{"location":"workflows/errors/#example-code_1","title":"Example Code","text":"<pre><code>tablevault = TableVault(db_dir='stories_tv', restart=True)\n</code></pre>"},{"location":"workflows/errors/#stop-process","title":"Stop Process","text":"<p>To explicitly stop and revert an active process, you can call the <code>stop_process()</code> function. If you want to materialize the partially generated dataframe, you can set the <code>materialize</code> boolean parameter to <code>True</code>. The dataframe becomes an active materialized instance, but its artifacts remain instance-specific and don't overwrite pre-existing table artifacts.</p> <p>The <code>get_active_processes()</code> function is useful for finding a list of all currently active processes.</p>"},{"location":"workflows/errors/#example-code_2","title":"Example Code","text":"<pre><code># materialize only applies to `execute_instance()` operations\ntablevault.stop_process(process_id=process_id, materialize=True)\n</code></pre>"},{"location":"workflows/workflow/","title":"Basic Workflow","text":"<p>This is a basic sample workflow for a TableVault repository.</p> <p>The full function API can be found in Core API. To understand the structures and files being created, please read through Core Concepts: Repository  and Core Concepts: Builders</p>"},{"location":"workflows/workflow/#1-make-a-repository","title":"1. Make a Repository","text":"<pre><code>tablevault = TableVault(db_dir=\"test_tv\", author=\"kong\", create=True,\n    description=\"This is an example repository.\")\n</code></pre>"},{"location":"workflows/workflow/#2-make-a-table","title":"2. Make a Table","text":"<pre><code>tablevault.create_table(table_name=\"fruits_table\", \n    description=\"This is an example table.\")\n</code></pre>"},{"location":"workflows/workflow/#3-make-a-table-instance","title":"3. Make a Table Instance","text":"<pre><code>tablevault.create_instance(table_name=\"fruits_table\")\n</code></pre>"},{"location":"workflows/workflow/#4-write-the-code-files","title":"4. Write the Code Files","text":"<pre><code>tablevault.create_code_module(module_name=\"example_code\")\n</code></pre> <p>Example Code</p> <p>You can fill out the code file with the following code:</p> <pre><code>import pandas as pd\n\ndef create_data_table_from_list(vals: list[str]):\n    return pd.DataFrame({\"temp_name\": vals})\n</code></pre> <p>If you do not have direct access to a text editor on your platform, you can add the code as a string argument, <code>text</code>, in <code>create_code_module()</code>.</p>"},{"location":"workflows/workflow/#5-write-the-builder-files","title":"5. Write the Builder Files","text":"<pre><code>tablevault.create_builder_file(table_name=\"fruits_table\", builder_name=\"fruits_table_index\")\n</code></pre> <p>Example Builder</p> <p>You can fill out the builder file with the following text:</p> <pre><code>builder_type: IndexBuilder\n\nchanged_columns: ['fruits']        # Output columns\nprimary_key: ['fruits']            # DataFrame primary key (optional)\n\npython_function: create_data_table_from_list       # Function to execute\ncode_module: example_code                 # Module containing the function\n\narguments:                               # Arguments passed to the function\n    vals: ['pineapples', 'watermelons', 'coconuts']\nis_custom: true                         # Using a user-supplied function in code_module\n</code></pre> <p>If you do not have direct access to a text editor on your platform, you can add the code as a string argument, <code>text</code>, in <code>create_builder_file()</code>.</p>"},{"location":"workflows/workflow/#6-materialize-the-instance","title":"6. Materialize the Instance","text":"<pre><code>tablevault.execute_instance(table_name=\"fruits_table\")\n</code></pre>"},{"location":"workflows/workflow/#7-create-a-second-instance","title":"7. Create a Second Instance","text":"<p>You can create a second instance of the <code>fruits_table</code> table in two different ways.</p>"},{"location":"workflows/workflow/#v1-copying-previous-instances","title":"(V1) Copying Previous Instances","text":"<p>To make building the dataframe easier, you can copy the metadata of the last materialized instance:</p> <pre><code>tablevault.create_instance(table_name=\"fruits_table\", copy=True)\n</code></pre> <p>You simply need to change one line in the <code>fruits_table_index.YAML</code> file:</p> <pre><code>arguments:                               # Arguments passed to the function\n    vals: ['bananas']\n</code></pre> <p>You can then execute normally:</p> <pre><code>tablevault.execute_instance(table_name=\"fruits_table\")\n</code></pre>"},{"location":"workflows/workflow/#v2-externally-writing-instances","title":"(V2) Externally Writing Instances","text":"<p>If you want to edit the dataframe outside of the TableVault library, you can explicitly declare this when generating the new instance: </p> <pre><code>tablevault.create_instance(table_name=\"fruits_table\", external_edit=True,\n    description=\"Externally created dataframe.\")\n</code></pre> <p>You can now write a new dataframe directly into our table:</p> <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'fruits': ['bananas']})\n\ntablevault.write_instance(df, table_name=\"fruits_table\")\n</code></pre> <p>External Execution is Untracked</p> <p>Edits to the dataframe made outside of the TableVault system are untracked. It is recommended that you fill out the <code>description</code> field in your instance to explain the edits, and keep your edits small and intuitive.</p>"},{"location":"workflows/workflow/#8-query-for-a-dataframe","title":"8. Query for a Dataframe","text":"<p>You can easily retrieve the dataframes of both instances: </p> <pre><code>instances = tablevault.get_instances(table_name=\"fruits_table\")\n\ndf_1 = tablevault.get_dataframe(table_name=\"fruits_table\", instance_id=instances[0])\ndf_2 = tablevault.get_dataframe(table_name=\"fruits_table\")\n</code></pre> <p>The dataframes should have the expected values:</p> df_1df_2 <pre><code>    fruits\n0   pineapples\n1   watermelons\n2   coconuts\n</code></pre> <pre><code>    fruits\n0   bananas\n</code></pre>"},{"location":"workflows/workflow_artifacts/","title":"Workflow with Artifacts","text":"<p>This is a basic workflow for handling artifacts in TableVault. To understand the basics of builders and artifacts, please read Core Concepts: Artifacts and the Builders Guide.</p>"},{"location":"workflows/workflow_artifacts/#1-creating-an-artifact-table-and-instance","title":"1. Creating an Artifact Table and Instance","text":"<p>You can continue from the TableVault repository generated from the Basic Workflow.</p> <pre><code>tablevault = TableVault(db_dir = \"test_tv\", author = \"dixie\")\ntablevault.create_table(table_name = \"fruit_images\", allow_multiple_artifacts = False)\ntablevault.create_instance(table_name = \"fruit_images\")\n</code></pre> <p>Setting <code>allow_multiple_artifacts</code> to <code>False</code> tells the system that there will only be one artifact repository for the entire folder.</p>"},{"location":"workflows/workflow_artifacts/#2-a-code-function-that-generates-artifacts","title":"2. A Code Function that Generates Artifacts","text":"<pre><code>tablevault.create_code_module(module_name = \"fetch_images\")\n</code></pre> <p>You can then populate the code file to import an image, given a type of fruit:</p> <pre><code>import shutil\n\ndef fetch_image_from_string(fruit: str, artifact_dir:str ):\n    file_path = f'./all_images/{fruit}.png' # pre-existing file\n    new_file_path = f'{artifact_dir}/{fruit}.png'\n\n    shutil.copy(file_path, new_file_path)\n\n    return f'{fruit}.png' # return relative path\n</code></pre> <p>If you don't have direct access to a text editor on your platform, you can add the code as a string argument, <code>text</code> in <code>create_code_module()</code>.</p> <p>Executing the Example</p> <p>In order for your code to actually execute, an actual image needs to exist in the  <code>file_path</code> location.</p>"},{"location":"workflows/workflow_artifacts/#3-a-builder-with-artifact_string","title":"3. A Builder with <code>~ARTIFACT_STRING~</code>","text":"<pre><code>tablevault.create_builder_file(\"fruit_images_index\")\ntablevault.create_builder_file(\"fetch_image_artifact\")\n</code></pre> fruit_images_index.yamlfetch_image_artifact.yaml <pre><code>builder_type: IndexBuilder\n\nchanged_columns: ['fruits']        # Output columns\nprimary_key: ['fruits']            # DataFrame primary key (optional)\n\npython_function: create_data_table_from_table           # Function to execute\ncode_module: table_generation                 # Module containing the function\n\narguments:                               # Arguments passed to the function\n    df: &lt;&lt;fruit_table.fruits&gt;&gt;                  \n</code></pre> <pre><code>builder_type: ColumnBuilder\n\nchanged_columns: ['fruit_image']                        # Output columns\n\npython_function: create_data_table_from_table           # Function to execute\ncode_module: table_generation                           # Module containing the function\n\nis_custom: true                  # Mark as user-supplied (searches in code_functions)\nreturn_type: row-wise            # Specifies if the function processes row by row\n\narguments:                                 # Arguments passed to the function\n    fruit: &lt;&lt;self.fruits[index]&gt;&gt; \n    artifact_dir: ~ARTIFACT_FOLDER~ \n\ndtypes:                           # Column Data Types \n    fruit_image: artifact_string            \n</code></pre> <p>If you don't have direct access to a text editor on your platform, you can add the code as a string argument, <code>text</code> in <code>create_code_module()</code>.</p>"},{"location":"workflows/workflow_artifacts/#4-execute-and-materialize-instance","title":"4. Execute and Materialize Instance","text":"<pre><code>tablevault.execute_instance(\"fruit_image\")\n</code></pre> <p>Strict Checks</p> <p>Various checks are performed before the table is materialized to ensure everything is configured correctly. Most importantly, each <code>artifact_string</code> value must have a corresponding artifact file and vice versa.</p>"},{"location":"workflows/workflow_artifacts/#5-query-for-an-artifact-dataframe","title":"5. Query for An Artifact Dataframe","text":"<p>You can easily retrieve the dataframe with the full or partial artifact path: </p> <pre><code>df_1 = tablevault.get_dataframe(table_name = \"fruits_table\", full_artifact_path = True)\ndf_2 = tablevault.get_dataframe(table_name = \"fruits_table\", full_artifact_path = False)\n</code></pre> <p>The dataframes should have the expected values:</p> df_1df_2 <pre><code>   fruits     fruit_image\n0  bananas    test_tv/fruit_image/artifacts/bananas.png\n</code></pre> <pre><code>   fruits     fruit_image\n0  bananas    bananas.png\n</code></pre>"}]}