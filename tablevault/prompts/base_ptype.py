from pydantic import BaseModel, Field, model_validator
from typing import Union, Optional
from tablevault.prompts.utils import utils
from tablevault.prompts.utils.table_string import TableValue, TableReference, parse_table_string, apply_table_string
from tablevault.defintions import constants, tv_errors, types
from tablevault.defintions.types import Cache
from tablevault.prompts.utils.artifact import apply_artifact_path

class TVPrompt(BaseModel):
    name: Union[str, TableReference] = Field(description="Name of prompt (autogenerated). Do not have to file.")
    dtypes: dict[Union[str, TableReference], Union[str, TableReference]] = Field(default={}, description="Specify Pandas datatype of output columns: column_name: dtype.")
    dependencies: list[TableValue] = Field(description="Specifies table dependecies of this prompt (autogenerated).")
    changed_columns: list[Union[str, TableReference]] = Field(description="Specifies the output column names that are generated.")
    ptype: Union[str, TableReference] = Field(description="Type of prompt. See tablevault.prompts.ptype_mapping for currently supported Prompts.")
    
    @model_validator(mode="before")
    @classmethod
    def transform_fields_to_table_string(cls, values):
        for field_name, model_field in cls.model_fields.items():
            if field_name in values:
                expected_type = model_field.annotation
                values[field_name] = parse_table_string(expected_type, values[field_name])
        values[constants.PROMPT_DEPENDENCIES] = _get_prompt_dependencies(values)
        return values

    def execute(self,
                cache: types.Cache,
                instance_id: str,
                table_name: str,
                db_dir: str):
        raise tv_errors.TVImplementationError('Not Implemented')
    
    def transform_table_string(self, 
                               cache: Cache,
                               instance_id: str,
                               table_name:str,
                               db_dir:str,
                               index: Optional[int]= None)-> None:
        
        for attr, val in vars(self).items():
            val_ = apply_table_string(val, cache, index)
            val_ = apply_artifact_path(val_, instance_id, table_name, db_dir)
            setattr(self, attr, val_)
        

def _get_table_dependencies(table_name: str, prompts: dict[str, TVPrompt]) -> list[str]:
    dependencies = set()
    for pname in prompts:
        for dep in prompts[pname].dependencies:
            if dep.table != constants.TABLE_SELF and dep.table != table_name:
                dependencies.add(dep.table)
    return list(dependencies)

def order_tables_by_prompts(all_prompts: dict[str, dict[str,TVPrompt]]):
    all_dependencies = {}
    for table_name in all_prompts:
        all_dependencies[table_name] = _get_table_dependencies(
            table_name, all_prompts[table_name]
        )
    table_names = utils.topological_sort(list(all_dependencies.keys()), all_dependencies)
    return table_names

def _get_prompt_dependencies(values):
    tables = []
    if isinstance(values, TableValue):
        return values.get_data_tables()
    elif isinstance(values, TableReference):
        return values.get_data_tables()
    elif isinstance(values, list):
        for value in values:
            tables += _get_prompt_dependencies(value)
    elif isinstance(values, set):
        for value in values:
            tables += _get_prompt_dependencies(value)
    elif isinstance(values,dict):
        for key, value in values.items():
            tables += _get_prompt_dependencies(key)
            tables += _get_prompt_dependencies(value)
    elif hasattr(values, '__dict__'):
        for _, val in vars(values).items():
            tables += _get_prompt_dependencies(val)        
    return tables