from pydantic import BaseModel, Field, model_validator
from typing import Union, Optional
from tablevault.col_builders.utils import utils
from tablevault.col_builders.utils.table_string import (
    TableValue,
    TableReference,
    parse_table_string,
    apply_table_string,
)
from tablevault.defintions import constants, tv_errors, types
from tablevault.defintions.types import Cache
from tablevault.col_builders.utils.artifact import apply_artifact_path


class TVBuilder(BaseModel):
    name: Union[str, TableReference] = Field(
        description="Name of builder (autogenerated). Do not have to file."
    )
    dtypes: dict[Union[str, TableReference], Union[str, TableReference]] = Field(
        default={},
        description="Specify Pandas datatype of output columns: column_name: dtype.",
    )
    dependencies: list[TableValue] = Field(
        description="Specifies table dependecies of this builder (autogenerated)."
    )
    changed_columns: list[Union[str, TableReference]] = Field(
        description="Specifies the output column names that are generated."
    )
    builder_type: Union[str, TableReference] = Field(
        description="""Type of builder. See
        tablevault.col_builders.builder_type_mapping for supported Builders."""
    )

    @model_validator(mode="before")
    @classmethod
    def transform_fields_to_table_string(cls, values):
        for field_name, model_field in cls.model_fields.items():
            if field_name in values:
                expected_type = model_field.annotation
                values[field_name] = parse_table_string(
                    expected_type, values[field_name]
                )
        values[constants.BUILDER_DEPENDENCIES] = _get_builder_dependencies(values)
        return values

    def execute(
        self,
        cache: types.Cache,
        instance_id: str,
        table_name: str,
        db_dir: str,
        process_id: str,
    ) -> Optional[bool]:
        raise tv_errors.TVImplementationError("Not Implemented")

    def transform_table_string(
        self,
        cache: Cache,
        instance_id: str,
        table_name: str,
        db_dir: str,
        index: Optional[int] = None,
    ) -> None:

        for attr, val in vars(self).items():
            val_ = apply_table_string(val, cache, index)
            val_ = apply_artifact_path(val_, instance_id, table_name, db_dir)
            setattr(self, attr, val_)


def _get_table_dependencies(
    table_name: str, builders: dict[str, TVBuilder]
) -> list[str]:
    dependencies = set()
    for builder_name in builders:
        for dep in builders[builder_name].dependencies:
            if dep.table != constants.TABLE_SELF and dep.table != table_name:
                dependencies.add(dep.table)
    return list(dependencies)


def order_tables_by_builders(all_builders: dict[str, dict[str, TVBuilder]]):
    all_dependencies = {}
    for table_name in all_builders:
        all_dependencies[table_name] = _get_table_dependencies(
            table_name, all_builders[table_name]
        )
    table_names = utils.topological_sort(
        list(all_dependencies.keys()), all_dependencies
    )
    return table_names


def _get_builder_dependencies(values):
    tables = []
    if isinstance(values, TableValue):
        return values.get_data_tables()
    elif isinstance(values, TableReference):
        return values.get_data_tables()
    elif isinstance(values, list):
        for value in values:
            tables += _get_builder_dependencies(value)
    elif isinstance(values, set):
        for value in values:
            tables += _get_builder_dependencies(value)
    elif isinstance(values, dict):
        for key, value in values.items():
            tables += _get_builder_dependencies(key)
            tables += _get_builder_dependencies(value)
    elif hasattr(values, "__dict__"):
        for _, val in vars(values).items():
            tables += _get_builder_dependencies(val)
    return tables
